import * as React from "react";
import { apiGet, apiPost } from "./common/ApiClient";
import { DISPUTE_REASONS, isAttachmentRequired } from "./common/DisputeReasons";
import { SharePointDisputeService } from "./common/SharePointDisputeService";
import CustomerLookup from "./customer/CustomerLookup";
import { ICustomerCard, ICustomerInfo, ICustomerLookupResult } from "./customer/ICustomerInfo";
import { IDisputeTransaction, IExistingDisputeRow } from "./models/IDisputeTransaction";

export type UiStatus = "idle" | "customerFound" | "starting" | "waiting" | "approved" | "rejected" | "failed" | "timeout";

export interface IProps {
  apiBaseUrl: string;
  spHttpClient: any;
  siteUrl: string;
  listTitle: string;
}

export interface IState {
  status: UiStatus;

  customer?: ICustomerInfo;
  cards?: ICustomerCard[];

  message?: string;

  // PACI
  requestId?: string;
  secondsLeft: number;
  resultCode?: number;
  resultDescription?: string;

  transactions: IDisputeTransaction[];

  loadingExisting: boolean;
  existingRows: IExistingDisputeRow[];

  // selectedCardNo?: string;
  // selectedCard?: ICustomerCard;

  // txnDate?: string;
  // txnTime?: string;
  // txnAmount?: string;
  // merchantName?: string;
  // disputeReason?: string;
  // comment?: string;
  // attachment?: File | null;

  submitting?: boolean;
  mockPaci: boolean;
}

export default class FlowardClaim extends React.Component<IProps, IState> {
  private pollTimer?: number;
  private countdownTimer?: number;

  private spSvc: SharePointDisputeService;

  constructor(props: IProps) {
    super(props);

    this.spSvc = new SharePointDisputeService(props.spHttpClient, props.siteUrl, props.listTitle);

    this.state = {
      status: "idle",
      secondsLeft: 300,
      transactions: [],
      loadingExisting: false,
      existingRows: [],
      submitting: false,
      mockPaci: true //
    };
  }

  public componentWillUnmount(): void {
    this.clearTimers();
  }

  public render(): React.ReactElement<IProps> {
    const { customer, cards, status, message, secondsLeft, requestId, transactions, existingRows, loadingExisting, submitting } = this.state;

    // const canAuth: boolean = !!(customer && customer.civilId && (status === "customerFound" || status === "idle"));
    // const isWaiting: boolean = status === "waiting" || status === "starting";

    // const isApproved: boolean = status === "approved";
    // const canSubmitRefund: boolean = isApproved && !!selectedCardNo && !!txnDate && !!txnTime && !!txnAmount && !!merchantName && !!disputeReason && !submitting;

    return (
      <div style={{ padding: 12, maxWidth: 1000 }}>
        <CustomerLookup apiBaseUrl={this.props.apiBaseUrl} onCustomerFound={this.onCustomerFound} onCustomerNotFound={this.onCustomerNotFound} />

        {customer && (
          <div style={{ marginTop: 12, border: "1px solid #ddd", padding: 12, borderRadius: 4 }}>
            <div style={{ marginBottom: 8 }}>
              <b>Customer:</b> {customer.fullNameEn} / {customer.fullNameAr}
            </div>
            <div style={{ marginBottom: 8 }}>
              <b>Civil ID</b> {customer.civilId}
            </div>

            <div style={{ marginTop: 10 }}>
              <label>
                <input type="checkbox" checked={this.state.mockPaci} onChange={(e) => this.setState({ mockPaci: (e.target as HTMLInputElement).checked })} /> Mock PACI Approval
                (testing)
              </label>
            </div>
            <button onClick={() => this.startPaciAuth()} disabled={status === "starting" || status === "waiting"} style={{ padding: "8px 14px" }}>
              Authenticate with PACI
            </button>

            {status === "waiting" && (
              <div style={{ marginTop: 10 }}>
                <div>
                  <b>RequestId:</b> {requestId}
                </div>
                <div>
                  <b>Time left:</b> {secondsLeft}s
                </div>
              </div>
            )}

            {message && <div style={{ marginTop: 10 }}>{message}</div>}

            {/* Existing transactions */}
            <div style={{ marginTop: 14 }}>
              <h4 style={{ margin: "10px 0" }}>Previous Transactions</h4>
              {loadingExisting ? <div>Loading previous transactions...</div> : this.renderExistingTable(existingRows)}
            </div>

            {/* {(status === "approved" || status === "rejected" || status === "failed" || status === "timeout") && (
              <div style={{ marginTop: 10, fontSize: 12 }}>
                {resultCode !== undefined && (
                  <div>
                    <b>ResultCode:</b> {resultCode}
                  </div>
                )}
                {resultDescription && (
                  <div>
                    <b>Description:</b> {resultDescription}
                  </div>
                )}
              </div>
            )} */}

            {/* After PACI approval - allow adding multiple transactions */}
            {status === "approved" && this.state.cards && this.state.cards.length > 0 && (
              <div style={{ marginTop: 14, borderTop: "1px solid #eee", paddingTop: 12 }}>
                <h4 style={{ marginTop: 0 }}>Add Transactions</h4>

                <button onClick={this.addTransactionRow} style={{ padding: "6px 12px" }}>
                  + Add Transaction
                </button>

                {transactions.length === 0 && <div style={{ marginTop: 10 }}>No transactions added yet.</div>}

                {transactions.map((t) => this.renderTransactionRow(t, cards))}

                <div style={{ marginTop: 12 }}>
                  <button onClick={this.submitToSharePoint} disabled={submitting || transactions.length === 0} style={{ padding: "8px 14px" }}>
                    {submitting ? "Submitting..." : "Submit"}
                  </button>
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    );

    {
      /* <div style={{ marginBottom: 10 }}>
                  <label style={{ display: "block", marginBottom: 4 }}>
                    <b>Select Card</b>
                  </label>
                  <select value={this.state.selectedCardNo || ""} onChange={this.onCardSelected} style={{ padding: 8, width: "100%" }}>
                    <option value="">--- Select card ----</option>
                    {this.state.cards.map((c, idx) => (
                      <option key={(c.cardNo || "") + "_" + idx} value={c.cardNo}>
                        {c.maskedCardNo}
                        {c.cardExpire ? " (Exp: " + c.cardExpire + ")" : ""}
                      </option>
                    ))}
                  </select>
                  {this.state.cards.length === 0 && <div style={{ marginTop: 6 }}>No cards found for this Civil ID.</div>}
                </div>

                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 10, maxWidth: 700 }}>
                  <div>
                    <label style={{ display: "block", marginBottom: 4 }}>
                      <b>Transaction date</b>
                    </label>
                    <input
                      type="date"
                      value={txnDate || ""}
                      onChange={(e) => this.setState({ txnDate: (e.target as HTMLInputElement).value })}
                      style={{ padding: 8, width: "100%" }}
                    />
                  </div>

                  <div>
                    <label style={{ display: "block", marginBottom: 4 }}>
                      <b>Transaction time</b>
                    </label>
                    <input
                      type="time"
                      value={txnTime || ""}
                      onChange={(e) => this.setState({ txnTime: (e.target as HTMLInputElement).value })}
                      style={{ padding: 8, width: "100%" }}
                    />
                  </div>

                  <div>
                    <label style={{ display: "block", marginBottom: 4 }}>
                      <b>Transaction amount</b>
                    </label>
                    <input
                      type="text"
                      value={txnAmount || ""}
                      onChange={(e) => {
                        const v = (e.target as HTMLInputElement).value;
                        // allow digits + one dot
                        if (/^\d*\.?\d*$/.test(v)) {
                          this.setState({ txnAmount: v });
                        }
                      }}
                      placeholder="e.g. 12.500"
                      style={{ padding: 8, width: "100%" }}
                    />
                  </div>

                  <div>
                    <label style={{ display: "block", marginBottom: 4 }}>
                      <b>Merchant name</b>
                    </label>
                    <input
                      type="text"
                      value={merchantName || ""}
                      onChange={(e) => this.setState({ merchantName: (e.target as HTMLInputElement).value })}
                      style={{ padding: 8, width: "100%" }}
                    />
                  </div>

                  <div style={{ gridColumn: "1 / span 2" }}>
                    <label style={{ display: "block", marginBottom: 4 }}>
                      <b>Dispute reason</b>
                    </label>
                    <select
                      value={disputeReason || ""}
                      onChange={(e) => this.setState({ disputeReason: (e.target as HTMLSelectElement).value })}
                      style={{ padding: 8, width: "100%", maxWidth: 520 }}>
                      {reasons.map((r) => (
                        <option key={r.key} value={r.key}>
                          {r.text}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div style={{ gridColumn: "1 / span 2" }}>
                    <label style={{ display: "block", marginBottom: 4 }}>
                      <b>Comment</b>
                    </label>
                    <textarea
                      value={comment || ""}
                      onChange={(e) => this.setState({ comment: (e.target as HTMLTextAreaElement).value })}
                      style={{ padding: 8, width: "100%", minHeight: 80 }}
                    />
                  </div>

                  <div style={{ gridColumn: "1 / span 2" }}>
                    <label style={{ display: "block", marginBottom: 4 }}>
                      <b>Attachment (optional)</b>
                    </label>
                    <input
                      type="file"
                      onChange={(e) => {
                        const files = (e.target as HTMLInputElement).files;
                        this.setState({ attachment: files && files.length > 0 ? files[0] : null });
                      }}
                    />
                  </div>
                </div>

                <div style={{ marginTop: 12, display: "flex", gap: 8 }}>
                  <button onClick={this.submitRefund} disabled={!canSubmitRefund} style={{ padding: "8px 14px" }}>
                    {submitting ? "Submitting..." : "Submit Refund Claim"}
                  </button>

                  <button onClick={this.resetFormOnly} disabled={submitting} style={{ padding: "8px 14px" }}>
                    Clear
                  </button>
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    );
  } */
    }
  }

  private renderExistingTable(rows: IExistingDisputeRow[]): React.ReactElement<any> {
    if (!rows || rows.length === 0) {
      return <div>No previous transactions found.</div>;
    }

    return (
      <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 12 }}>
        <thead>
          <tr>
            <th style={th}>ID</th>
            <th style={th}>Status</th>
            <th style={th}>Card</th>
            <th style={th}>Date</th>
            <th style={th}>Time</th>
            <th style={th}>Amount</th>
            <th style={th}>Merchant</th>
            <th style={th}>Reason</th>
            <th style={th}>Created</th>
          </tr>
        </thead>
        <tbody>
          {rows.map((r) => (
            <tr key={r.id}>
              <td style={td}>{r.id}</td>
              <td style={td}>{r.status || ""}</td>
              <td style={td}>{r.cardMasked || ""}</td>
              <td style={td}>{r.txnDate || ""}</td>
              <td style={td}>{r.txnTime || ""}</td>
              <td style={td}>{r.txnAmount !== undefined ? r.txnAmount : ""}</td>
              <td style={td}>{r.merchantName || ""}</td>
              <td style={td}>{r.disputeReason || ""}</td>
              <td style={td}>{r.created || ""}</td>
            </tr>
          ))}
        </tbody>
      </table>
    );
  }

  private renderTransactionRow(t: IDisputeTransaction, cards: ICustomerCard[]): React.ReactElement<any> {
    const attachmentNeeded = isAttachmentRequired(t.disputeReason);
    const rowError = this.validateOneTransaction(t);

    return (
      <div key={t.localId} style={{ marginTop: 12, border: "1px solid #ddd", padding: 12, borderRadius: 4 }}>
        <div style={{ display: "flex", justifyContent: "space-between", gap: 8 }}>
          <b>Transaction</b>
          <button onClick={() => this.removeTransactionRow(t.localId)} style={{ padding: "4px 10px" }}>
            Remove
          </button>
        </div>

        {rowError && <div style={{ marginTop: 6, color: "#b00020" }}>{rowError}</div>}

        <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 10, marginTop: 10 }}>
          <div>
            <div>
              <b>Card</b>
            </div>
            <select
              value={t.cardNo || ""}
              onChange={(e) => this.updateTransaction(t.localId, { cardNo: (e.target as HTMLSelectElement).value })}
              style={{ padding: 8, width: "100%" }}>
              <option value="">-- Select card --</option>
              {cards.map((c) => (
                <option key={c.cardNo} value={c.cardNo}>
                  {c.maskedCardNo}
                </option>
              ))}
            </select>
          </div>

          <div>
            <div>
              <b>Dispute Reason</b>
            </div>
            <select
              value={t.disputeReason || ""}
              onChange={(e) => this.updateTransaction(t.localId, { disputeReason: (e.target as HTMLSelectElement).value })}
              style={{ padding: 8, width: "100%" }}>
              {DISPUTE_REASONS.map((r) => (
                <option key={r.key} value={r.key}>
                  {r.text}
                </option>
              ))}
            </select>
            {attachmentNeeded && (
              <div style={{ fontSize: 12, marginTop: 4 }}>
                <b>Attachment is required</b> for this reason.
              </div>
            )}
          </div>

          <div>
            <div>
              <b>Transaction Date</b>
            </div>
            <input
              type="date"
              value={t.txnDate || ""}
              onChange={(e) => this.updateTransaction(t.localId, { txnDate: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div>
            <div>
              <b>Transaction Time</b>
            </div>
            <input
              type="time"
              value={t.txnTime || ""}
              onChange={(e) => this.updateTransaction(t.localId, { txnTime: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div>
            <div>
              <b>Transaction Amount</b>
            </div>
            <input
              type="text"
              value={t.txnAmount || ""}
              onChange={(e) => {
                const v = (e.target as HTMLInputElement).value;
                if (/^\d*\.?\d*$/.test(v)) {
                  this.updateTransaction(t.localId, { txnAmount: v });
                }
              }}
              placeholder="e.g. 12.500"
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div>
            <div>
              <b>Merchant Name</b>
            </div>
            <input
              type="text"
              value={t.merchantName || ""}
              onChange={(e) => this.updateTransaction(t.localId, { merchantName: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div style={{ gridColumn: "1 / span 2" }}>
            <div>
              <b>Comment</b>
            </div>
            <textarea
              value={t.comment || ""}
              onChange={(e) => this.updateTransaction(t.localId, { comment: (e.target as HTMLTextAreaElement).value })}
              style={{ padding: 8, width: "100%", minHeight: 70 }}
            />
          </div>

          <div style={{ gridColumn: "1 / span 2" }}>
            <div>
              <b>Attachment {attachmentNeeded ? "(Required)" : "(Optional)"}</b>
            </div>
            <input
              type="file"
              onChange={(e) => {
                const files = (e.target as HTMLInputElement).files;
                this.updateTransaction(t.localId, { attachment: files && files.length > 0 ? files[0] : null });
              }}
            />
            {t.attachment && <div style={{ fontSize: 12, marginTop: 4 }}>{t.attachment.name}</div>}
          </div>
        </div>
      </div>
    );
  }

  private clearTimers(): void {
    if (this.pollTimer !== undefined) {
      window.clearInterval(this.pollTimer);
      this.pollTimer = undefined;
    }
    if (this.countdownTimer !== undefined) {
      window.clearInterval(this.countdownTimer);
      this.countdownTimer = undefined;
    }
  }

  private onCustomerFound = async (result: ICustomerLookupResult): Promise<void> => {
    this.clearTimers();
    this.setState({
      customer: result.customer,
      cards: result.cards,
      status: "customerFound",
      message: undefined,
      requestId: undefined,
      secondsLeft: 300,
      resultCode: undefined,
      resultDescription: undefined,
      transactions: [],
      loadingExisting: true,
      existingRows: []
    });

    // load existing disputes for civilId
    try {
      const rows = await this.spSvc.getExistingByCivilId(result.customer.civilId);
      this.setState({ existingRows: rows, loadingExisting: false });
    } catch (e) {
      this.setState({
        existingRows: [],
        loadingExisting: false,
        message: "Failed to load previous transactions: " + (e && (e as any).message ? (e as any).message : "")
      });
    }
  };

  private onCustomerNotFound = (msg: string) => {
    this.clearTimers();
    this.setState({
      customer: undefined,
      cards: undefined,
      status: "idle",
      message: msg,
      requestId: undefined,
      secondsLeft: 300,
      resultCode: undefined,
      resultDescription: undefined,
      transactions: [],
      existingRows: [],
      loadingExisting: false
    });
  };

  private async startPaciAuth(): Promise<void> {
    const customer: ICustomerInfo = this.state.customer;
    if (!customer || !customer.civilId) {
      this.setState({ status: "failed", message: "Please lookup valid Civil ID first." });
      return;
    }

    // MOCK MODE (temporary)
    if (this.state.mockPaci) {
      this.clearTimers();

      const fakeRequestId = "MOCK - " + new Date().getTime();

      this.setState({
        status: "approved",
        requestId: fakeRequestId,
        resultCode: 10,
        resultDescription: "Authenticated (Mock)",
        message: "PACI Approved (Mock mode)",
        secondsLeft: 300
      });

      return;
    }

    // REAL PACI
    this.clearTimers();
    this.setState({ status: "starting", message: "Sending PACI authentication request...", secondsLeft: 300 });
    try {
      const url: string = this.props.apiBaseUrl.replace(/\/$/, "") + "/api/paci/initiate-auth";

      const resp = await apiPost<{ requestId: string }>(url, {
        authenticationReasonAr: "الحصول على تفويض العميل لتحديث بيانات البطاقة المدنية",
        authenticationReasonEn: "Get Customer Approval to update Civil Details",
        civilNo: customer.civilId,
        assuranceLevel: "Medium",
        serviceDescriptionEN: "Refund claim for a Gift Card",
        serviceDescriptionAR: "طلب استرداد مبلغ لبطاقة الهدايا",
        additionalData: "",
        challenge: ""
      });

      if (!resp || !resp.requestId) {
        this.setState({ status: "failed", message: "No RequestId returned from PACI initiate API." });
        return;
      }

      this.setState({ status: "waiting", requestId: resp.requestId, message: "Waiting for customer approval..." });

      this.startCountdown(resp.requestId);
      this.startPolling(resp.requestId);
    } catch (e) {
      this.setState({ status: "failed", message: e && (e as any).message ? (e as any).message : "Failed to initiate PACI auth." });
    }
  }

  private startCountdown(requestId: string) {
    this.countdownTimer = window.setInterval(() => {
      this.setState((prev) => {
        const next = prev.secondsLeft - 1;
        if (next <= 0) {
          this.clearTimers();
          return { ...prev, secondsLeft: 0, status: "timeout", message: "Timed out (5 minutes). No response received." };
        }
        return { ...prev, secondsLeft: next };
      });
    }, 1000);
  }

  private startPolling(requestId: string) {
    this.pollTimer = window.setInterval(async () => {
      try {
        const url = this.props.apiBaseUrl.replace(/\/$/, "") + "/api/paci/status/" + encodeURIComponent(requestId);

        const s = await apiGet<{
          requestId: string;
          isProcessed: boolean;
          resultCode?: number;
          resultDescription?: string;
        }>(url);

        if (!s || !s.isProcessed) {
          return;
        }

        this.clearTimers();

        const rc: number = s.resultCode;
        const desc: string = s.resultDescription;

        if (rc === 10) {
          this.setState({ status: "approved", resultCode: rc, resultDescription: desc, message: desc || "Authenticated" });
        } else if (rc === 40) {
          this.setState({ status: "rejected", resultCode: rc, resultDescription: desc, message: desc || "Declined" });
        } else {
          this.setState({ status: "failed", resultCode: rc, resultDescription: desc, message: desc || "Failed" });
        }
      } catch (err) {
        // keep polling quietly
      }
    }, 3000);
  }

  private addTransactionRow = (): void => {
    const id = "t_" + new Date().getTime() + "_" + Math.floor(Math.random() * 1000);

    const next: IDisputeTransaction = { localId: id, attachment: null };
    this.setState((prev) => ({
      transactions: prev.transactions.concat([next])
    }));
  };

  private removeTransactionRow = (localId: string): void => {
    this.setState((prev) => ({
      transactions: prev.transactions.filter((x) => x.localId !== localId)
    }));
  };

  private updateTransaction = (localId: string, patch: Partial<IDisputeTransaction>): void => {
    this.setState((prev) => ({
      transactions: prev.transactions.map((x) => (x.localId === localId ? { ...x, ...patch } : x))
    }));
  };

  private validateOneTransaction(t: IDisputeTransaction): string | null {
    if (!t.cardNo) return "Card is required.";
    if (!t.txnDate) return "Transaction date is required.";
    if (!t.txnTime) return "Transaction time is required.";
    if (!t.txnAmount || isNaN(Number(t.txnAmount))) return "Valid amount is required.";
    if (!t.merchantName) return "Merchant name is required.";
    if (!t.disputeReason) return "Dispute reason is required.";

    if (isAttachmentRequired(t.disputeReason) && !t.attachment) {
      return "Attachment is required for selected dispute reason.";
    }

    return null;
  }

  private validateAll(): string | null {
    if (this.state.status !== "approved") return "PACI must be approved before submitting.";
    if (!this.state.customer) return "Customer is missing.";
    if (!this.state.requestId) return "PACI RequestId is missing.";
    if (!this.state.transactions || this.state.transactions.length === 0) return "Please add at least one transaction.";

    for (let i = 0; i < this.state.transactions.length; i++) {
      const err = this.validateOneTransaction(this.state.transactions[i]);
      if (err) return "Row " + (i + 1) + ": " + err;
    }

    return null;
  }

  private submitToSharePoint = async (): Promise<void> => {
    const err = this.validateAll();
    if (err) {
      this.setState({ message: err });
      return;
    }

    const customer = this.state.customer!;
    const paciRequestId = this.state.requestId!;
    const cards = this.state.cards || [];

    this.setState({ submitting: true, message: "Submitting to SharePoint..." });

    try {
      for (let i = 0; i < this.state.transactions.length; i++) {
        const t = this.state.transactions[i];

        // get masked card
        let masked = "";
        for (let c = 0; c < cards.length; c++) {
          if (cards[c].cardNo === t.cardNo) {
            masked = cards[c].maskedCardNo;
            break;
          }
        }

        const itemId = await this.spSvc.addDisputeItem({
          civilId: customer.civilId,
          paciRequestId: paciRequestId,
          cardNo: t.cardNo!,
          maskedCardNo: masked,
          txnDate: t.txnDate!,
          txnTime: t.txnTime!,
          txnAmount: Number(t.txnAmount),
          merchantName: t.merchantName!,
          disputeReason: t.disputeReason!,
          comment: t.comment || ""
        });

        if (t.attachment) {
          await this.spSvc.addAttachment(itemId, t.attachment);
        }
      }

      // refresh existing table
      const rows = await this.spSvc.getExistingByCivilId(customer.civilId);

      this.setState({
        submitting: false,
        message: "Submitted successfully.",
        transactions: [],
        existingRows: rows
      });
    } catch (e) {
      this.setState({
        submitting: false,
        message: "Submit failed: " + (e && (e as any).message ? (e as any).message : e ? e.toString() : "")
      });
    }
  };

  // private onCardSelected = (e: React.ChangeEvent<HTMLSelectElement>): void => {
  //   const cardNo = e.target.value;
  //   const customer = this.state.customer;

  //   let picked: ICustomerCard | undefined;
  //   const cards = this.state.cards || [];
  //   for (let i = 0; i < cards.length; i++) {
  //     if (cards[i].cardNo === cardNo) {
  //       picked = cards[i];
  //       break;
  //     }
  //   }

  //   this.setState({
  //     selectedCardNo: cardNo || undefined,
  //     selectedCard: picked
  //   });
  // };

  // private resetFormOnly = (): void => {
  //   this.setState({
  //     selectedCardNo: undefined,
  //     selectedCard: undefined,
  //     txnDate: undefined,
  //     txnTime: undefined,
  //     txnAmount: undefined,
  //     merchantName: undefined,
  //     disputeReason: undefined,
  //     comment: undefined,
  //     attachment: null,
  //     message: undefined
  //   });
  // };

  // private submitRefund = async (): Promise<void> => {
  //   const customer = this.state.customer;
  //   const card = this.state.selectedCard;
  //   if (!customer || !card) {
  //     this.setState({ message: "Please select a card." });
  //     return;
  //   }

  //   if (this.state.status !== "approved") {
  //     this.setState({ message: "Customer is not authenticated yet." });
  //     return;
  //   }

  //   // Basic client-side checks
  //   if (!this.state.txnDate || !this.state.txnTime || !this.state.txnAmount || !this.state.merchantName || !this.state.disputeReason) {
  //     this.setState({ message: "Please fill all required fields." });
  //     return;
  //   }

  //   this.setState({ submitting: true, message: "Submitting refund claim..." });

  //   try {
  //     const url = this.props.apiBaseUrl.replace(/\/$/, "") + "/api/floward/refund/full";

  //     const payload: any = {
  //       cardExid: card.cardExid || "",
  //       userId: this.context.pageContext.user.loginName
  //     };

  //     await apiPost<any>(url, payload);

  //     this.setState({
  //       submitting: false,
  //       message: "Refund claim submitted successfully."
  //     });
  //   } catch (e) {
  //     this.setState({
  //       submitting: false,
  //       message: e && e.message ? e.message : "Failed to submit refund claim."
  //     });
  //   }
  // };
}
const th: React.CSSProperties = { borderBottom: "1px solid #ddd", textAlign: "left", padding: 6 };
const td: React.CSSProperties = { borderBottom: "1px solid #f0f0f0", padding: 6, verticalAlign: "top" };



