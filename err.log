import { WebPartContext } from "@microsoft/sp-webpart-base";
import { sp } from "@pnp/sp";
import {
	AlignmentType,
	BorderStyle,
	Document,
	HeadingLevel,
	HeightRule,
	Packer,
	Paragraph,
	Table,
	TableCell,
	TableRow,
	TextRun,
	UnderlineType,
	WidthType
} from "docx";
import * as saveAs from "file-saver";
import { Status, getCurrentContractEmployee, getCurrentUserGroups, gradeNotInclude } from "../../util";

const saveDocumentToFile = (doc: any, fileName: string) => {
	// Create a mime type that will associate the new file with Microsoft Word
	const mimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
	// Create a Blob containing the Document instance and the mimeType
	Packer.toBlob(doc).then(blob => {
		const docblob = blob.slice(0, blob.size, mimeType);
		// Save the file using saveAs from the file-saver package
		saveAs(docblob, fileName);
	});
};

const formatWeightWithTwoDecimalsAndPercentage = (value: any): string => {
	if (value === null || value === undefined || value === "") {
		return "";
	}

	const num = Number(value);
	if (isNaN(num)) {
		return "";
	}
	// const formattedNumber = String(number) === "" ? "" : number.toFixed(2);
	// if (formattedNumber !== "" && formattedNumber.indexOf(".") === -1) {
	// 	return formattedNumber + ".00 %";
	// }
	return `${num.toFixed(2)} %`;
};

interface IGroupedData {
	category: string;
	totalWeight: number;
	userKPIs: Array<{ KPIDescription: string; Weight: number; }>;
}

const getUserKPI = async (contractId: number, selectedYear: number) => {
	const currentYear =
		await sp.web.lists.getByTitle("Year").items
			.select("Id", "Title")
			.getById(selectedYear)();

	const prevYearTitle = (Number(currentYear.Title) - 1).toString();

	const prevYear =
		await sp.web.lists.getByTitle("Year").items
			.select("Id", "Title")
			.filter(`Title eq '${prevYearTitle}'`)
			.top(1)();

	const previousYearTitle = prevYear.length > 0 ? prevYear[0].Title : null;

	const dataUserKPI = await sp.web.lists
		.getByTitle("UserKPI")
		.items
		.select("Category/Title", "SubCategory/SubCategory", "Weight", "KPIDescription", "Category/EndResultOverwriteString", "Start", "End", "LastYearClosing", "Baseline", "EndTarget")
		.expand("Category", "SubCategory")
		.filter(`ContractId eq ${contractId} and isDeleted eq false`)
		.orderBy("Weight", false)
		.orderBy("Category/Order0", true)
		.get();

	const result = dataUserKPI.reduce((acc, obj) => {
		const { Category, Weight, KPIDescription, SubCategory, Start, End, LastYearClosing, Baseline, EndTarget } = obj;
		const key = Category.Title;
		if (!acc[key]) {
			acc[key] = { category: key, totalWeight: 0, userKPIs: [], overwrite: false };
		}
		if (Category.EndResultOverwriteString === "false") {
			acc[key].totalWeight += Weight;
		} else {
			acc[key].overwrite = true;
		}

		acc[key].userKPIs.push({ KPIDescription, Start, End, LastYearClosing, Baseline, EndTarget, SubCategory: SubCategory.SubCategory, Weight: Category.EndResultOverwriteString === "false" ? Weight : null });

		return acc;
	}, {} as { [key: string]: IGroupedData });

	const finalResult = Object.values(result);
	const grandTotalWeight = finalResult.reduce((acc, group: any) => acc + group.totalWeight, 0);

	const rows: TableRow[] = [];
	let row: TableRow;
	finalResult.forEach((group: any) => {
		row = new TableRow({
			height: {
				value: 1250,
				rule: HeightRule.AUTO
			},
			children: [
				new TableCell({
					margins: {
						top: 80,
						bottom: 80
					},
					children: [new Paragraph({
						text: group.category,
						style: "tableRowCategory",
					})]
				}),
				new TableCell({
					margins: {
						top: 80,
						bottom: 80,
						right: 100,
					},
					children: [new Paragraph({
						text: group.overwrite ? "" : formatWeightWithTwoDecimalsAndPercentage(group.totalWeight),
						style: "tableRowCategory",
						alignment: AlignmentType.RIGHT,
					})]
				})
			]
		});
		rows.push(row);
		group.userKPIs.forEach((userKPI: any) => {
			row = new TableRow({
				height: {
					value: 1250,
					rule: HeightRule.AUTO
				},
				children: [
					new TableCell({
						margins: {
							right: 300,
							top: 80,
							bottom: 80
						},
						children: [new Paragraph({
							text: userKPI.SubCategory === "Financial" ? `${userKPI.KPIDescription} (Q${userKPI.Start} - Q${userKPI.End})` : userKPI.KPIDescription,
							style: "tableRow"
						}),
						...(userKPI.SubCategory === "Financial"
							? [new TableRow({
								height: {
									value: 1250,
									rule: HeightRule.AUTO
								},
								children: [new TableCell({
									margins: {
										right: 300,
										top: 80,
										bottom: 80
									},
									children: [new Paragraph({
										text: `${previousYearTitle} closing`
									})]
								}),
								new TableCell({
									margins: {
										right: 300,
										top: 80,
										bottom: 80
									},
									children: [new Paragraph({
										text: userKPI.LastYearClosing
									})]
								})]
							})] : [])]
					}),
					new TableCell({
						margins: {
							right: 100,
							top: 80,
							bottom: 80
						},
						children: [new Paragraph({
							text: formatWeightWithTwoDecimalsAndPercentage(userKPI.Weight),
							style: "tableRow",
							alignment: AlignmentType.RIGHT,
						})]
					})
				]
			});
			rows.push(row);
		});
	});

	row = new TableRow({
		height: {
			value: 1250,
			rule: HeightRule.AUTO
		},
		children: [
			new TableCell({
				margins: {
					right: 300,
					top: 80,
					bottom: 80
				},
				children: [new Paragraph({
					alignment: AlignmentType.RIGHT,
					children: [new TextRun({
						text: "Total",
						bold: true,
						italics: true,
						underline: {
							type: UnderlineType.SINGLE,
							color: "000000"
						},
						font: "Century Gothic",
						size: 16,
					}),
					]
				})]
			}),
			new TableCell({
				margins: {
					top: 80,
					bottom: 80,
					right: 100,
				},
				children: [new Paragraph({
					alignment: AlignmentType.RIGHT,
					children: [new TextRun({
						text: formatWeightWithTwoDecimalsAndPercentage(Number(grandTotalWeight)),
						bold: true,
						underline: {
							type: UnderlineType.SINGLE,
							color: "000000"
						},
						font: "Century Gothic",
						size: 16,
					})]
				})]
			})
		]
	});
	rows.push(row);

	const emptyRow = new TableRow({
		height: {
			value: 1250,
			rule: HeightRule.EXACT
		},
		children: [
			new TableCell({
				children: [new Paragraph({})]
			}),
			new TableCell({
				children: [new Paragraph({})]
			})
		]
	});
	for (let i = 0; i < 2; i++) {
		rows.push(emptyRow);
	}

	const table = new Table({
		borders: {
			top: {
				style: BorderStyle.NONE,
				size: 0,
				color: "auto"
			},
			bottom: {
				style: BorderStyle.NIL,
				size: 0,
				color: "auto"
			},
			left: {
				style: BorderStyle.NIL,
				size: 0,
				color: "auto"
			},
			right: {
				style: BorderStyle.NIL,
				size: 0,
				color: "auto"
			},
			insideHorizontal: {
				style: BorderStyle.NIL,
				size: 0,
				color: "auto"
			},
			insideVertical: {
				style: BorderStyle.NIL,
				size: 0,
				color: "auto"
			}
		},
		width: {
			size: 100,
			type: WidthType.PERCENTAGE
		},
		rows: [
			new TableRow({
				height: {
					value: 1250,
					rule: HeightRule.AUTO
				},
				children: [
					new TableCell({
						margins: {
							top: 80,
							bottom: 80,
							right: 100,
						},
						width: {
							size: 85,
							type: WidthType.PERCENTAGE
						},
						children: [new Paragraph({
							text: "Indicator**",
							style: "tableHeader",
						})]
					}),
					new TableCell({
						margins: {
							top: 80,
							bottom: 80,
							right: 100,
						},
						width: {
							size: 15,
							type: WidthType.PERCENTAGE
						},
						children: [new Paragraph({
							alignment: AlignmentType.RIGHT,
							text: "Weight",
							style: "tableHeader",
						})]
					}),
				]
			}),
			...rows
		]
	});

	return table;
};

const generateContracts = async (gridSelectedContracts: any[], selectedContractYear: number) => {
	const today = new Date();
	const paragraph = await Promise.all(
		gridSelectedContracts.map(async (gridSelectedContract, index) => {
			const arr = [];
			arr.push(
				new Paragraph({
					text: `${gridSelectedContract.Year.Title} PERFORMANCE CONTRACT`,
					heading: HeadingLevel.HEADING_1,
				}));
			arr.push(
				new Paragraph({
					style: "normalPara",
					children: [
						new TextRun({
							text: "Performance Contract between ",
							font: "Century Gothic",
							size: 16
						}),
						new TextRun({
							text: `${gridSelectedContract.Employee.Title}`,
							font: "Century Gothic",
							size: 16,
							underline: {
								type: UnderlineType.SINGLE,
								color: "000000",
							},
						}),
						new TextRun({
							text: " and ",
							font: "Century Gothic",
							size: 16
						}),
						new TextRun({
							text: `Boubyan Bank`,
							font: "Century Gothic",
							size: 16,
							underline: {
								type: UnderlineType.SINGLE,
								color: "000000",
							},
						}),
						new TextRun({
							text: ", whereby it is agreed as follows:",
							font: "Century Gothic",
							size: 16
						}),
					]
				}));
			arr.push(
				new Paragraph({
					text: "In pursuit of achieving the business objectives of Boubyan Bank, I commit myself to achieve the Key Performance Indicators and outcomes contained in my Performance Contract.",
					style: "normalPara"
				}));
			arr.push(
				new Paragraph({
					text: `This Agreement signed ${String(today.getDate()).padStart(2, "0")} ${today.toLocaleString("default", { month: "long" })} ${gridSelectedContract.Year.Title}, will be valid for the year ending 31 December ${gridSelectedContract.Year.Title}, and is subject to review on a quarterly basis.`,
					style: "normalPara"
				}));
			const userKPI = await getUserKPI(gridSelectedContract.Id, selectedContractYear);
			arr.push(userKPI);

			arr.push(
				new Paragraph({}));

			arr.push(
				new Table({
					borders: {
						top: {
							style: BorderStyle.NONE,
							size: 0,
							color: "auto"
						},
						bottom: {
							style: BorderStyle.NIL,
							size: 0,
							color: "auto"
						},
						left: {
							style: BorderStyle.NIL,
							size: 0,
							color: "auto"
						},
						right: {
							style: BorderStyle.NIL,
							size: 0,
							color: "auto"
						},
						insideHorizontal: {
							style: BorderStyle.NIL,
							size: 0,
							color: "auto"
						},
						insideVertical: {
							style: BorderStyle.NIL,
							size: 0,
							color: "auto"
						}
					},
					width: {
						size: 100,
						type: WidthType.PERCENTAGE
					},
					rows: [
						new TableRow({
							height: {
								value: 1250,
								rule: HeightRule.EXACT
							},
							children: [
								new TableCell({
									children: [
										new Paragraph({
											children: [
												new TextRun({
													text: "________________________",
													font: "Century Gothic",
													size: 16,
													bold: true
												})
											],
											alignment: AlignmentType.CENTER,
										}),
										new Paragraph({
											children: [
												new TextRun({
													text: "Adel Al-Majed",
													font: "Century Gothic",
													size: 16,
													bold: true
												})
											],
											alignment: AlignmentType.CENTER,
										}),
										new Paragraph({
											children: [
												new TextRun({
													text: "Vice Chairman & Chief Executive Officer",
													font: "Century Gothic",
													size: 16
												})
											],
											alignment: AlignmentType.CENTER,
										})
									]
								}),
								new TableCell({
									children: [
										new Paragraph({
											children: [
												new TextRun({
													text: "________________________",
													font: "Century Gothic",
													size: 16,
													bold: true
												})
											],
											alignment: AlignmentType.CENTER,
										}),
										new Paragraph({
											children: [
												new TextRun({
													text: gridSelectedContract.Employee.Title,
													font: "Century Gothic",
													size: 16,
													bold: true,
												})
											],
											alignment: AlignmentType.CENTER,
										}),
										new Paragraph({
											children: [
												new TextRun({
													text: gridSelectedContract.Employee.Position,
													font: "Century Gothic",
													size: 16,
												})
											],
											alignment: AlignmentType.CENTER,
										})
									]
								})
							]
						})
					]
				})
			);

			if (index < gridSelectedContracts.length - 1) {
				arr.push(new Paragraph({ pageBreakBefore: true }));
			}

			return arr;
		})
	);

	return paragraph.reduce((prev, curr) => prev.concat(curr), []);
};

export const reportPerformanceContract = async (selectedContract: number, selectedContractYear: number, context: WebPartContext) => {
	const html =
		`<div class="row">
			<h3>
				<small class="text-muted">Performace Contract</small>
			</h3>
		</div>
    <div id="gridContract"></div>`;

	$("#content").empty();
	$("#content").html(html);

	const currentUserGroup = await getCurrentUserGroups();
	const isMember = currentUserGroup.indexOf("EPMS Admin") > -1;
	const filter = !isMember ? ` and Employee/DirectManagerEmail eq '${context.pageContext.legacyPageContext.userEmail}'` : "";

	let contracts = await sp.web.lists.getByTitle("Contract")
		.items
		.filter(`YearId eq ${selectedContractYear} and isDeleted eq false and Employee/isDeletedString eq false${filter}`)
		.select("Id", "Status", "Stage", "Period", "EmployeeId", "YearId", "Employee/Title", "Employee/EmployeeId", "Employee/Group",
			"Employee/Division", "Employee/Department", "Employee/DirectManager", "Employee/Grade", "Employee/Position", "Year/Title")
		.expand("Employee", "Year")
		.getAll();

	const currentEmployee = await getCurrentContractEmployee(selectedContractYear, context);

	const assignRoles = await sp.web.lists
		.getByTitle("AssignRoles")
		.items
		.select("Id")
		.filter(`EmployeeId eq '${currentEmployee[0].EmployeeId}' and YearId eq ${selectedContractYear} and isDeleted eq false`)
		.getAll();

	if (assignRoles.length > 0) {
		const assignRoleChild = await sp.web.lists
			.getByTitle("AssignRoleGroupDivision")
			.items
			.select("Id", "Title")
			.filter(`YearId eq ${selectedContractYear} and AssignRoleId eq ${assignRoles[0].Id}`)
			.getAll();

		for (let i = 0; i < assignRoleChild.length; i++) {
			const PMOEmployee = await sp.web.lists
				.getByTitle("Contract")
				.items
				.select("Id", "Status", "Stage", "Period", "EmployeeId", "YearId", "Employee/Title", "Employee/EmployeeId", "Employee/Group"
					, "Employee/Division", "Employee/Department", "Employee/DirectManager", "Employee/Grade", "Employee/Position", "Year/Title")
				.expand("Employee", "Year")
				.filter(`(Employee/Title eq '${assignRoleChild[i].Title}' or Employee/Group eq '${assignRoleChild[i].Title}' or Employee/Division eq '${assignRoleChild[i].Title}'
				or Employee/Department eq '${assignRoleChild[i].Title}') and YearId eq ${selectedContractYear} and isDeleted eq false and Employee/isDeletedString eq false`)
				.get();

			contracts = contracts.concat(PMOEmployee);
		}
	}

	/**
	 * Added to remove employee less than grade 12 && Status not InActive
	**/
	contracts = contracts.filter(x => !gradeNotInclude.includes(x.Employee.Grade) && x.Status !== Status.InActive);
	/**
	 * Added to remove employee less than grade 12 && Status not InActive
	**/

	const gridContract = $("#gridContract").dxDataGrid({
		dataSource: contracts,
		keyExpr: "Id",
		showBorders: true,
		showRowLines: true,
		rowAlternationEnabled: true,
		selection: {
			allowSelectAll: true,
			selectAllMode: "allPages",
			mode: "multiple",
			showCheckBoxesMode: "onClick"
		},
		paging: {
			enabled: true,
			pageSize: 15
		},
		pager: {
			visible: true,
			showInfo: true,
			showPageSizeSelector: true,
			allowedPageSizes: [15, 50, 100, "all"]
		},
		sorting: {
			mode: "multiple"
		},
		filterRow: {
			visible: true,
			applyFilter: "auto"
		},
		toolbar: {
			items: [{
				location: "after",
				widget: "dxButton",
				options: {
					type: "default",
					text: "Generate Report",
					onClick: async (e) => {
						const gridSelectedContracts = gridContract.getSelectedRowsData();

						if (gridSelectedContracts.length === 0) {
							DevExpress.ui.dialog.alert("Please select AUTO one contract to generate report", "EPMS");
							return;
						}

						gridContract.beginCustomLoading("Generating report....");
						const doc = new Document(
							{
								sections: [{
									properties: {},
									children: [...await generateContracts(gridSelectedContracts, selectedContractYear)]
								}],
								styles: {
									default: {
										heading1: {
											run: {
												font: "Century Gothic",
												size: 20,
												bold: true,
												color: "000000",
											},
											paragraph: {
												alignment: AlignmentType.CENTER,
												spacing: {
													line: 240,
													// after: 40
												}
											}
										}
									},
									paragraphStyles: [{
										id: "normalPara",
										name: "Normal Para",
										basedOn: "Normal",
										next: "Normal",
										quickFormat: true,
										run: {
											font: "Century Gothic",
											size: 16,
											color: "000000",
										},
										paragraph: {
											alignment: AlignmentType.JUSTIFIED,
											spacing: {
												line: 240,
												before: 240,
												after: 240
											}
										}
									}, {
										id: "tableHeader",
										name: "Table Header",
										basedOn: "Normal",
										next: "Normal",
										quickFormat: true,
										run: {
											font: "Century Gothic",
											size: 16,
											color: "000000",
											bold: true,
											italics: true,
											underline: {
												type: UnderlineType.SINGLE,
												color: "000000",
											},
										},
									}, {
										id: "tableRow",
										name: "Table Row",
										basedOn: "Normal",
										next: "Normal",
										quickFormat: true,
										run: {
											font: "Century Gothic",
											size: 16,
											color: "000000"
										}
									}, {
										id: "tableRowCategory",
										name: "Table Row Category",
										basedOn: "Normal",
										next: "Normal",
										quickFormat: true,
										run: {
											font: "Century Gothic",
											size: 16,
											color: "000000",
											bold: true,
										}
									}]
								},
							}
						);

						saveDocumentToFile(doc, `ContractPerformace_${new Date().getTime()}.docx`);
						gridContract.endCustomLoading();
					}
				}
			}]
		},
		columns: [{
			dataField: "Employee.EmployeeId",
			caption: "Employee Id",
			width: "auto"
		}, {
			dataField: "Employee.Title",
			caption: "Employee name",
			width: "auto"
		}, {
			dataField: "Employee.Group",
			caption: "Group",
			width: "auto"
		}, {
			dataField: "Employee.Department",
			caption: "Department",
			width: "auto"
		}, {
			dataField: "Employee.Division",
			caption: "Division",
			width: "auto"
		}, {
			dataField: "Employee.DirectManager",
			caption: "Direct manager",
			width: "auto"
		}, {
			dataField: "Employee.Grade",
			caption: "Grade",
			width: "auto"
		}, {
			dataField: "Status",
			caption: "Status",
			width: "auto"
		}, {
			dataField: "Stage",
			caption: "Stage",
			width: "auto"
		}, {
			dataField: "Period",
			caption: "Period",
			width: "auto"
		}]
	}).dxDataGrid("instance");
};
