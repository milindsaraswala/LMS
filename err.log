import * as React from "react";
import { SharePointCaseService } from "../../common";
import { mapNintexOutcomeToCaseStatus } from "../../common/CaseStatusCalculator";
import NintexWorkflowService from "../../common/NintexWorkflowService";
import { INintexOutcome, INintexTask } from "../../models/INintexTask";

export interface IProps {
  nintexSvc: NintexWorkflowService;
  caseSvc: SharePointCaseService;
  listName: string;
  itemId: number;
  onActionCompleted: () => void;
}

export interface IState {
  loading: boolean;
  task: INintexTask | null;
  outcomes: INintexOutcome[];
  selectedOutcome?: INintexOutcome;
  comment: string;
  submitting: boolean;
  error?: string;
}

export default class WorkflowActionPanel extends React.Component<IProps, IState> {
  constructor(props: IProps) {
    super(props);

    this.state = {
      loading: true,
      task: null,
      outcomes: [],
      comment: "",
      submitting: false
    };
  }

  public componentDidMount(): void {
    this.loadTask();
  }

  public render(): React.ReactElement<any> {
    if (this.state.loading) {
      return <div>Loading workflow actions...</div>;
    }

    if (!this.state.task) {
      return null;
    }

    return (
      <div
        style={{
          marginTop: 20,
          padding: 12,
          border: "1px solid #ddd",
          background: "#fafafa"
        }}>
        <h4>Workflow Actions</h4>

        <div style={{ marginBottom: 8 }}>
          {this.state.outcomes.map((o) => (
            <button
              key={o.id}
              onClick={() => this.setState({ selectedOutcome: o })}
              style={{
                marginRight: 8,
                padding: "6px 12px",
                background: this.state.selectedOutcome && this.state.selectedOutcome.id === o.id ? "#0078d4" : "#e0e0e0",
                color: this.state.selectedOutcome && this.state.selectedOutcome.id === o.id ? "#fff" : "#000",
                border: "none"
              }}>
              {o.name}
            </button>
          ))}
        </div>

        {this.state.selectedOutcome && this.state.selectedOutcome.commentMode !== "None" && (
          <div style={{ marginTop: 10 }}>
            <div>
              <b>Comment</b>
            </div>
            <textarea value={this.state.comment} onChange={(e) => this.setState({ comment: (e.target as HTMLTextAreaElement).value })} style={{ width: "100%", minHeight: 70 }} />
          </div>
        )}

        <div style={{ marginTop: 12 }}>
          {this.state.error && (
            <div
              style={{
                marginTop: 10,
                marginBottom: 10,
                padding: "8px 10px",
                background: "#fdecea",
                color: "#b00020",
                border: "1px solid #f5c6cb",
                borderRadius: 4,
                fontSize: 13
              }}>
              {this.state.error}
            </div>
          )}
          <button
            disabled={this.state.submitting || !this.state.selectedOutcome}
            onClick={async () => {
              if (!this.validateBeforeSubmit(this.state.selectedOutcome)) {
                return;
              }
              await this.submit();
            }}
            style={{
              padding: "8px 16px",
              background: "#0078d4",
              color: "#fff",
              border: "none"
            }}>
            {this.state.submitting ? "Processing..." : "Submit"}
          </button>
        </div>
      </div>
    );
  }

  private async loadTask(): Promise<void> {
    try {
      const task = await this.props.nintexSvc.getRunningTask(this.props.listName, this.props.itemId);

      if (!task || task.taskType !== "MultiOutcome") {
        this.setState({ loading: false, task: null });
        return;
      }

      const outcomes = await this.props.nintexSvc.getFlexiTaskOutcomes(task.sharePointTaskId, task.taskListName);

      this.setState({
        loading: false,
        task: task,
        outcomes: outcomes
      });
    } catch (e) {
      this.setState({
        loading: false,
        error: "Failed to load workflow task."
      });
    }
  }

  private validateBeforeSubmit(outcome: INintexOutcome): boolean {
    if (outcome.commentMode === "Required" && !this.state.comment && !this.state.comment.trim()) {
      this.setState({
        error: "Comment is required for this action."
      });
      return false;
      // alert("Comment is madatory for this action.");
      // return false;
    }

    this.setState({ error: undefined });
    return true;
  }

  private submit = async (): Promise<void> => {
    const t = this.state.task;
    const o = this.state.selectedOutcome;

    if (!t || !o) {
      return;
    }

    if (o.commentMode === "Required" && !this.state.comment) {
      alert("Comment is required.");
      return;
    }

    this.setState({ submitting: true });

    try {
      const caseStatus = mapNintexOutcomeToCaseStatus(o.name);

      if (caseStatus) {
        await this.props.caseSvc.updateCaseStatus(this.props.itemId, caseStatus, o.name);
      }

      await this.props.nintexSvc.completeTaskWithHistory({
        task: this.state.task,
        outcome: o.name,
        comment: this.state.comment,
        caseItemId: this.props.itemId
      });

      this.setState({
        comment: ""
      });
      this.props.onActionCompleted();
    } catch (e) {
      alert("Workflow action failed.");
    } finally {
      this.setState({ submitting: false });
    }
  };
}
