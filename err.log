import * as React from 'react';
import { Course, Lesson, Module } from '../common/models';
import { getSP } from '../common/pnp';
import { dedupeConcat, mergeObjects } from '../common/utils';

type Props = { context: any; courseId?: number; courseCode?: string; preview?: boolean };
type QuizState = {
	answers: { [qid: string]: Set<string> };
	submitted: boolean;
	score?: { points: number; max: number; percent: number; passed: boolean };
};
type ProgressModel = {
	completed: number[];
	bookmarkLessonId?: number;
	videoPos?: { [lessonId: number]: number };
	quiz?: { [lessonId: number]: { points: number; max: number; percent: number; passed: boolean } };
};
type Enrollment = { id: number; progress: ProgressModel };
type State = {
	loading: boolean;
	course?: Course;
	modules: Module[];
	lessonsByModule: { [k: number]: Lesson[] };
	activeModuleId?: number;
	activeLessonId?: number;
	error?: string;

	quizByLesson: { [lessonId: number]: QuizState };
	enrollment?: Enrollment;
};

export default class CoursePlayer extends React.Component<Props, State> {
	constructor(props: Props) {
		super(props);
		this.state = { loading: true, modules: [], lessonsByModule: {}, quizByLesson: {} };
	}

	public componentDidMount() {
		this.load();
	}

	public render() {
		if (this.state.loading) return <div>Loading…</div>;
		if (this.state.error) return <div style={{ color: 'red' }}>Error: {this.state.error}</div>;

		const { modules, lessonsByModule, activeModuleId, activeLessonId } = this.state;
		const active = activeModuleId && activeLessonId ? (lessonsByModule[activeModuleId] || []).filter((x) => x.Id === activeLessonId)[0] : null;

		return (
			<div style={{ display: 'flex', gap: 16 }}>
				{/* Sidebar */}
				<div style={{ width: 320, minWidth: 280, maxHeight: '70vh', overflow: 'auto', borderRight: '1px solid #eee', paddingRight: 8 }}>
					{modules.map((m) => {
						const unlocked = this.isModuleUnlocked(m);
						return (
							<div key={m.Id} style={{ marginBottom: 12, opacity: unlocked ? 1 : 0.5 }}>
								<div style={{ fontWeight: 700, marginBottom: 6 }}>
									{m.Title} {!unlocked ? <span style={{ fontSize: 12, color: '#a00' }}>(Locked)</span> : null}
								</div>
								<ul style={{ listStyle: 'none', paddingLeft: 0, margin: 0 }}>
									{(lessonsByModule[m.Id] || []).map((l) => {
										const _active = this.state.activeModuleId === m.Id && this.state.activeLessonId === l.Id;
										const completed = this.isLessonCompleted(l.Id);
										const disabled = !unlocked;
										return (
											<li key={l.Id}>
												<a
													href='#'
													onClick={(e) => {
														e.preventDefault();
														if (disabled) return;
														this.setState({ activeModuleId: m.Id, activeLessonId: l.Id });
														this.saveProgress({ bookmarkLessonId: l.Id }); // keep resume updated as user navigates
													}}
													style={{
														display: 'flex',
														gap: 6,
														alignItems: 'center',
														padding: '6px 8px',
														borderRadius: 4,
														textDecoration: 'none',
														color: disabled ? '#888' : _active ? '#fff' : '#222',
														background: _active ? '#0078d4' : 'transparent',
														pointerEvents: disabled ? 'none' : 'auto'
													}}
													title={disabled ? 'Complete previous modules to unlock' : l.Title}>
													<span style={{ width: 14 }}>{completed ? '✓' : ''}</span>
													<span style={{ flex: 1, minWidth: 0, whiteSpace: 'normal' }}>
														{(l.Order0 || 0) + '. '}
														{l.Title}
													</span>
												</a>
											</li>
										);
									})}
								</ul>
							</div>
						);
					})}
				</div>

				{/* Player */}
				<div style={{ flex: 1, minWidth: 0 }}>
					{active ? (
						<div>
							{/* sticky header */}
							<div style={{ position: 'sticky', top: 0, background: '#fff', zIndex: 2, padding: '6px 0', borderBottom: '1px solid #eee', marginBottom: 8 }}>
								<div style={{ fontSize: 18, fontWeight: 700 }}>
									{active.Title} {this.renderLessonActions(active)}
								</div>
								<div style={{ opacity: 0.7, fontSize: 12 }}>
									{(active.ContentTypeChoice || '').toUpperCase()}
									{active.EstimatedMinutes ? ` • ${active.EstimatedMinutes} min` : ''}
								</div>
								{this.renderNavBar()}
							</div>

							{/* content */}
							{this.renderLesson(active)}
						</div>
					) : (
						<div>Select a lesson…</div>
					)}
				</div>
			</div>
		);
	}

	private getCourseIdFromQS(): number | null {
		const qs = new URLSearchParams(window.location.search);
		const v = qs.get('courseId');
		return v ? Number(v) : null;
	}

	private escOData(s: string) {
		// tslint:disable-next-line
		return (s || '').replace(/'/g, "''");
	}

	private async resolveCourseId(sp: any): Promise<number | null> {
		const qs = this.getCourseIdFromQS();
		if (qs && !isNaN(qs)) return qs;

		if (this.props.courseId && this.props.courseId > 0) return Number(this.props.courseId);

		if (this.props.courseCode) {
			const code = this.escOData(this.props.courseCode);
			const found = await sp.web.lists.getByTitle('Courses').items.select('Id', 'Code').filter(`Code eq '${code}'`).top(1)();
			return found.length ? found[0].Id : null;
		}
		return null;
	}

	private async load() {
		const sp = getSP(this.props.context);

		try {
			const resolved = await this.resolveCourseId(sp);
			const id = resolved != null ? Number(resolved) : NaN;
			if (!isFinite(id) || id <= 0) {
				this.setState({ loading: false, error: 'No courseId configured' });
				return;
			}

			// Course
			const courseItem = await sp.web.lists.getByTitle('Courses').items.select('Id', 'Title', 'Description', 'ThumbnailUrl').filter(`Id eq ${id}`).top(1)();
			if (!courseItem.length) {
				this.setState({ loading: false, error: 'Course not found' });
				return;
			}
			const course = courseItem[0];
			this.setState({
				course: { Id: course.Id, Title: course.Title, Description: course.Description, ThumbnailUrl: course.ThumbnailUrl }
			});

			const modsRaw = await sp.web.lists
				.getByTitle('Modules')
				.items.select('Id', 'Title', 'Order0', 'CourseId')
				.filter(`CourseId eq ${id}`)
				.orderBy('Order0', true)
				.orderBy('Id', true)
				.top(5000)();

			const modules: Module[] = modsRaw.map((m: any) => ({
				Id: m.Id,
				Title: m.Title,
				Order0: m.Order0,
				CourseId: id
			}));
			this.setState({ modules });

			const lessonsBy: { [k: number]: Lesson[] } = {};
			if (modules.length) {
				const ids: number[] = modules.map((m) => m.Id);

				const lessonsRaw = await sp.web.lists
					.getByTitle('Lessons')
					.items.select('Id', 'Title', 'Order0', 'ContentTypeChoice', 'ContentUrl', 'HtmlContent', 'QuizJson', 'EstimatedMinutes', 'Module/Id', 'Module/Title')
					.expand('Module')
					.orderBy('ModuleId', true)
					.orderBy('Order0', true)
					.orderBy('Id', true)
					.top(5000)();

				(lessonsRaw || []).forEach((l: Lesson) => {
					const modId = l.Module ? l.Module.Id : l.ModuleId;

					if (ids.indexOf(modId) === -1) return;

					const contentUrl = this.getUrlString(l.ContentUrl);

					(lessonsBy[modId] = lessonsBy[modId] || []).push({
						Id: l.Id,
						Title: l.Title,
						Order0: l.Order0,
						ContentTypeChoice: l.ContentTypeChoice,
						ContentUrl: contentUrl,
						HtmlContent: l.HtmlContent,
						QuizJson: l.QuizJson,
						EstimatedMinutes: l.EstimatedMinutes,
						ModuleId: modId
					} as Lesson);
				});
			}

			const enrollment = await this.getOrCreateEnrollment(sp, id);

			const moduleIds = modules.map((m) => m.Id);
			const byMod = lessonsBy;

			let startModId = modules.length ? modules[0].Id : undefined;
			let startLessonId: number | undefined = undefined;

			const bookmark = enrollment.progress.bookmarkLessonId;
			if (bookmark) {
				for (const mid of moduleIds) {
					const hit = (byMod[mid] || []).find((l) => l.Id === bookmark);
					if (hit) {
						startModId = mid;
						startLessonId = hit.Id;
						break;
					}
				}
			}

			if (!startLessonId) {
				outer: for (const mid of moduleIds) {
					for (const l of byMod[mid] || []) {
						if (!this.isLessonCompleted(l.Id)) {
							startModId = mid;
							startLessonId = l.Id;
							break outer;
						}
					}
				}
			}

			if (!startLessonId && startModId) {
				const list = byMod[startModId] || [];
				startLessonId = list.length ? list[0].Id : undefined;
			}

			this.setState({
				lessonsByModule: lessonsBy,
				activeModuleId: startModId,
				activeLessonId: startLessonId,
				loading: false,
				enrollment
			});

			const firstModuleId = modules.length ? modules[0].Id : undefined;
			const firstLessonId = firstModuleId && lessonsBy[firstModuleId] && lessonsBy[firstModuleId][0] ? lessonsBy[firstModuleId][0].Id : undefined;

			this.setState({
				lessonsByModule: lessonsBy,
				activeModuleId: firstModuleId,
				activeLessonId: firstLessonId,
				loading: false
			});
		} catch (e) {
			this.setState({ loading: false, error: e && (e as any).message ? (e as any).message : String(e) });
		}
	}

	private renderLesson(l: Lesson) {
		const kind = (l.ContentTypeChoice || '').toUpperCase();
		const url = (l.ContentUrl || '').trim();
		const ext = this.ext(url);

		// HTML
		if (kind === 'HTML') return <div style={{ border: '1px solid #eee', padding: 10 }} dangerouslySetInnerHTML={{ __html: l.HtmlContent || '' }} />;

		// PDF
		if (kind === 'PDF' || ext === '.pdf') {
			const raw = (l.ContentUrl || '').trim();
			if (!raw) return <div style={{ color: '#a00' }}>No PDF URL configured.</div>;

			// If file is in your SharePoint tenant → use WOPI
			/*if (this.isSameOrigin(raw)) {
				const wopi = this.toWopiEmbedUrl(raw);
				const alt = this.toWopiPreviewUrl(raw);
				return (
					<div>
						<iframe
							src={wopi}
							style={{ width: '100%', height: 600, border: 0 }}
							onError={(e) => {
								const f = e.currentTarget as HTMLIFrameElement;
								if (f && f.src !== alt) f.src = alt;
							}}
						/>
						<div style={{ marginTop: 6 }}>
							<a href={this.ensureAbsoluteUrl(raw)} target='_blank' rel='noreferrer'>
								Open PDF
							</a>
						</div>
					</div>
				);
			}*/

			// External PDFs (not same origin):
			// Try native browser PDF viewer; if blocked by CSP/X-Frame-Options, the link still works.
			const abs = this.ensureAbsoluteUrl(raw);
			return (
				<div>
					<object data={abs} type='application/pdf' style={{ width: '100%', height: 600 }}>
						<embed src={abs} type='application/pdf' />
					</object>
					<div style={{ marginTop: 6 }}>
						<a href={abs} target='_blank' rel='noreferrer'>
							Open PDF
						</a>
					</div>
				</div>
			);
		}

		// PPT/DOC/XLS via WOPI
		if (kind === 'PPT' || kind === 'DOC' || kind === 'XLS' || ext === '.ppt' || ext === '.pptx' || ext === '.doc' || ext === '.docx' || ext === '.xls' || ext === '.xlsx') {
			if (!url) return <div style={{ color: '#a00' }}>No file URL configured.</div>;
			const wopi = this.toWopiEmbedUrl(url);
			return (
				<div>
					<iframe src={wopi} style={{ width: '100%', height: 600, border: 0 }} />
					<div style={{ marginTop: 6 }}>
						<a href={this.ensureAbsoluteUrl(url)} target='_blank'>
							Open file
						</a>
					</div>
				</div>
			);
		}

		// LINK (generic)
		if (kind === 'LINK') {
			if (!url) return <div style={{ color: '#a00' }}>No link set.</div>;
			return (
				<a href={this.ensureAbsoluteUrl(url)} target='_blank'>
					{url}
				</a>
			);
		}

		// VIDEO
		if (kind === 'VIDEO') {
			if (!url) return <div style={{ color: '#a00' }}>No video URL.</div>;
			return (
				<video
					src={this.ensureAbsoluteUrl(url)}
					controls
					style={{ width: '100%' }}
					onTimeUpdate={(e) => {
						const t = (e.currentTarget as HTMLVideoElement).currentTime;
						const lessonId = l.Id;
						const cur = this.getVideoPosMap();
						// Throttle saves or save locally; here just local state to avoid spamming the list:
						this.setState((s) => ({
							enrollment: s.enrollment
								? {
										...s.enrollment,
										progress: { ...s.enrollment.progress, videoPos: { ...cur, [lessonId]: t } }
								  }
								: s.enrollment
						}));
					}}
					onPause={async (ev) => {
						// const cur = this.state.enrollment && this.state.enrollment.progress && this.state.enrollment.progress.videoPos ? this.state.enrollment.progress.videoPos : {};
						const pos = (ev.currentTarget as HTMLVideoElement).currentTime;
						const patch: any = { videoPos: {} };
						patch.videoPos[l.Id] = pos;
						await this.saveProgress(patch); // persist on pause
					}}
					onLoadedMetadata={(e) => {
						const t = this.getSavedVideoTime(l.Id);
						if (t !== null) {
							(e.currentTarget as HTMLVideoElement).currentTime = t;
						}
					}}
				/>
			);
		}

		// AUDIO
		if (kind === 'AUDIO') {
			if (!url) return <div style={{ color: '#a00' }}>No audio URL.</div>;
			return <audio src={this.ensureAbsoluteUrl(url)} controls />;
		}

		// QUIZ (read-only preview)
		if (kind === 'QUIZ') {
			const model = this.getQuizModel(l);
			if (!model || !Array.isArray(model.questions) || model.questions.length === 0) {
				return <div style={{ color: '#a00' }}>No questions configured.</div>;
			}
			const qState = this.getQuizState(l.Id);
			const submitted = qState.submitted;
			const score = qState.score;

			return (
				<div>
					{model.title ? <div style={{ fontWeight: 700, marginBottom: 8 }}>{model.title}</div> : null}

					{model.questions.map((q: any, qi: number) => {
						const chosen = qState.answers[q.id] || new Set<string>();
						const single = q.type === 'single' || q.type === 'boolean';
						const correct = new Set(q.correctOptionIds || []);

						return (
							<div key={q.id || qi} style={{ border: '1px solid #eee', borderRadius: 6, padding: 10, marginBottom: 10 }}>
								<div style={{ fontWeight: 600, marginBottom: 6 }}>
									Q{qi + 1} ({q.type}) • {q.points || 1} pt
								</div>
								<div style={{ marginBottom: 8 }}>{q.text}</div>

								{(q.options || []).map((o: any) => {
									const checked = chosen.has(o.id);
									// after submit, show correctness styling
									const showCheck = submitted;
									const isCorrectOption = correct.has(o.id);
									const isUserChoice = checked;

									let rowStyle: React.CSSProperties = { padding: '4px 6px', borderRadius: 4, display: 'flex', alignItems: 'center', gap: 8 };
									if (showCheck) {
										if (isCorrectOption) rowStyle.background = '#e7f7ee'; // greenish for correct answer
										if (isUserChoice && !isCorrectOption) rowStyle.background = '#fdeaea'; // reddish for wrong chosen
									}

									return (
										<label key={o.id} style={rowStyle}>
											<input
												type={single ? 'radio' : 'checkbox'}
												name={single ? `q_${q.id}` : undefined}
												checked={checked}
												disabled={submitted}
												onChange={(e) => this.toggleAnswer(l.Id, q, o.id, e.currentTarget.checked)}
											/>
											<span>{o.text}</span>
										</label>
									);
								})}
							</div>
						);
					})}

					{!submitted ? (
						<div style={{ marginTop: 8 }}>
							<button onClick={() => this.submitQuiz(l.Id, model)}>Submit</button>
						</div>
					) : (
						<div style={{ marginTop: 8 }}>
							<div style={{ fontWeight: 700 }}>
								Score: {score && score.points}/{score && score.max} ({score && score.percent}%){' '}
								{score && score.passed ? <span style={{ color: '#0a7' }}>• Passed</span> : <span style={{ color: '#c00' }}>• Not passed</span>}
							</div>
							{score && !score.passed ? (
								<div style={{ marginTop: 6 }}>
									<button onClick={() => this.resetQuiz(l.Id)}>Try again</button>
								</div>
							) : null}
						</div>
					)}
				</div>
			);
		}

		return <div>Unsupported content.</div>;
	}

	private getUrlString = (v: any): string => (v && typeof v === 'object' ? v.Url || v.url || '' : v || '');

	private ensureAbsoluteUrl = (u: string) => (!u ? '' : /^https?:\/\//i.test(u) ? u : location.origin + (u.startsWith('/') ? u : '/' + u));

	private cleanFileUrl = (u: string) => {
		if (!u) return '';
		const a = document.createElement('a');
		a.href = this.ensureAbsoluteUrl(u);
		// remove ?web=1 and other viewer flags; keep the base path
		a.search = a.search
			.replace(/([?&])web=1(&|$)/i, '$1') // drop web=1
			.replace(/([?&])download=1(&|$)/i, '$1') // drop download=1
			.replace(/([?&])action=[^&]*/i, '') // drop action=
			.replace(/^[?&]+$/, '');
		return a.pathname ? location.origin + a.pathname : this.ensureAbsoluteUrl(u);
	};

	private toPdfViewerUrl = (u: string) => {
		const abs = this.ensureAbsoluteUrl(u);
		// SharePoint PDF viewer (works with tenant files & server-relative paths)
		return `${location.origin}/_layouts/15/pdfviewer.aspx?file=${encodeURIComponent(abs)}&action=default`;
	};

	private toWopiEmbedUrl = (u: string) => {
		const abs = this.cleanFileUrl(u);
		// WOPI works for PDFs & Office docs if the file is in your tenant
		return `${location.origin}/_layouts/15/WopiFrame.aspx?sourcedoc=${encodeURIComponent(abs)}&action=embedview`;
	};

	private toWopiPreviewUrl = (u: string) => {
		const abs = this.cleanFileUrl(u);
		return `${location.origin}/_layouts/15/WopiFrame.aspx?sourcedoc=${encodeURIComponent(abs)}&action=interactivepreview`;
	};

	private ext = (u: string) => {
		const m = (u || '').toLowerCase().match(/\.[a-z0-9]+(\?|#|$)/);
		return m ? m[0] : '';
	};

	private isSameOrigin = (u: string) => {
		try {
			const { origin } = new URL(this.ensureAbsoluteUrl(u));
			return origin === location.origin;
		} catch {
			return false;
		}
	};

	private renderNavBar = () => {
		const { modules, lessonsByModule, activeModuleId, activeLessonId } = this.state;
		if (!activeModuleId || !activeLessonId) return null;
		const list = lessonsByModule[activeModuleId] || [];
		const idx = list.findIndex((l) => l.Id === activeLessonId);
		const prev = idx > 0 ? list[idx - 1] : null;
		const next = idx >= 0 && idx < list.length - 1 ? list[idx + 1] : null;
		const go = (l?: Lesson) => l && this.setState({ activeLessonId: l.Id });
		const pct = list.length ? Math.round(((idx + 1) / list.length) * 100) : 0;
		return (
			<div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 6 }}>
				<button disabled={!prev} onClick={() => go(prev)}>
					◀ Prev
				</button>
				<div style={{ flex: 1, height: 6, background: '#eee', borderRadius: 3 }}>
					<div style={{ width: `${pct}%`, height: 6, background: '#0078d4', borderRadius: 3 }} />
				</div>
				<span style={{ width: 38, textAlign: 'right', fontSize: 12 }}>{pct}%</span>
				<button disabled={!next} onClick={() => go(next)}>
					Next ▶
				</button>
			</div>
		);
	};

	private getQuizModel = (l: Lesson) => {
		try {
			return l.QuizJson ? JSON.parse(l.QuizJson as any) : null;
		} catch {
			return null;
		}
	};

	private getQuizState = (lessonId: number): QuizState => {
		return this.state.quizByLesson[lessonId] || { answers: {}, submitted: false };
	};

	private setQuizState = (lessonId: number, patch: Partial<QuizState>) => {
		this.setState((s) => ({
			quizByLesson: {
				...s.quizByLesson,
				[lessonId]: { ...s.quizByLesson[lessonId], ...patch }
			}
		}));
	};

	private toggleAnswer = (lessonId: number, q: any, optId: string, checked: boolean) => {
		const qs = this.getQuizState(lessonId);
		const cur = new Set(qs.answers[q.id] || []);
		if (q.type === 'single' || q.type === 'boolean') {
			// single select
			const next = checked ? new Set([optId]) : new Set<string>();
			qs.answers[q.id] = next;
		} else {
			// multiple
			checked ? cur.add(optId) : cur.delete(optId);
			qs.answers[q.id] = cur;
		}
		this.setQuizState(lessonId, { answers: { ...qs.answers } });
	};

	private submitQuiz = async (lessonId: number, qModel: any) => {
		const qs = this.getQuizState(lessonId);
		let points = 0;
		let max = 0;

		(qModel.questions || []).forEach((q: any) => {
			const correct = new Set<string>(q.correctOptionIds || []);
			const chosen = qs.answers[q.id] || new Set<string>();
			const qPoints = Number(q.points) > 0 ? Number(q.points) : 1;
			max += qPoints;

			// mark correct if sets equal
			let ok = true;
			if (ok)
				correct.forEach((id) => {
					if (!chosen.has(id)) ok = false;
				});
			if (ok) points += qPoints;
		});

		const percent = max ? Math.round((points / max) * 100) : 0;
		const passed = percent >= 70;
		const result = { points, max, percent, passed };

		await this.saveProgress({ quiz: { [lessonId]: result } });
		this.setQuizState(lessonId, { submitted: true, score: result });

		if (passed) await this.saveProgress({ completed: [lessonId] });
	};

	private resetQuiz = (lessonId: number) => {
		this.setQuizState(lessonId, { answers: {}, submitted: false, score: undefined });
	};

	private async getOrCreateEnrollment(sp: any, courseId: number): Promise<Enrollment> {
		const me = await sp.web.currentUser();
		const uid = me.Id;

		const found = await sp.web.lists
			.getByTitle('CourseEnrollments')
			.items.select('Id', 'CourseId', 'UserId', 'ProgressJson')
			.filter(`CourseId eq ${courseId} and UserId eq ${uid}`)
			.top(1)();

		if (found.length) {
			const p: ProgressModel = this.parseProgress(found[0].ProgressJson);
			return { id: found[0].Id, progress: p };
		}

		const blank: ProgressModel = { completed: [] };
		const add = await sp.web.lists.getByTitle('CourseEnrollments').items.add({
			Title: `Course ${courseId} - User ${uid}`,
			CourseId: courseId,
			UserId: uid,
			ProgressJson: JSON.stringify(blank),
			Status: 'InProgress',
			StartedOn: new Date()
		});

		return { id: add.data.Id, progress: blank };
	}

	private parseProgress(json: string | null | undefined): ProgressModel {
		try {
			const p = json ? JSON.parse(json) : null;
			return p && typeof p === 'object'
				? { completed: p.completed || [], bookmarkLessonId: p.bookmarkLessonId, videoPos: p.videoPos || {}, quiz: p.quiz || {} }
				: { completed: [] };
		} catch {
			return { completed: [] };
		}
	}

	private async saveProgress(patch: Partial<ProgressModel>) {
		if (!this.state.enrollment) return;

		const current = this.state.enrollment.progress;

		const mergedCompleted = dedupeConcat(current.completed, patch.completed);
		const mergedBookmark = typeof patch.bookmarkLessonId === 'number' ? patch.bookmarkLessonId : current.bookmarkLessonId;

		const mergedVideoPos = mergeObjects(current.videoPos, patch.videoPos);
		const mergedQuiz = mergeObjects(current.quiz, patch.quiz);

		const merged: ProgressModel = {
			completed: mergedCompleted,
			bookmarkLessonId: mergedBookmark,
			videoPos: mergedVideoPos,
			quiz: mergedQuiz
		};

		const sp = getSP(this.props.context);
		await sp.web.lists
			.getByTitle('CourseEnrollments')
			.items.getById(this.state.enrollment.id)
			.update({
				ProgressJson: JSON.stringify(merged)
			});
		this.setState({ enrollment: { id: this.state.enrollment.id, progress: merged } as Enrollment });
	}

	// Convenience:
	private isLessonCompleted = (lessonId: number) => {
		const p = this.state.enrollment && this.state.enrollment.progress;
		return p ? (p.completed || []).indexOf(lessonId) >= 0 : false;
	};

	private renderLessonActions(l: Lesson) {
		const completed = this.isLessonCompleted(l.Id);
		const kind = (l.ContentTypeChoice || '').toUpperCase();
		// If quiz: require pass

		let canComplete = true;
		if (kind === 'QUIZ') {
			const enr = this.state.enrollment;
			const score = enr && enr.progress && enr.progress.quiz ? enr.progress.quiz[l.Id] : undefined;
			canComplete = score ? score.passed === true : false;
		}

		return (
			<div style={{ marginTop: 6, display: 'flex', gap: 8, alignItems: 'center' }}>
				<button
					disabled={completed || !canComplete}
					onClick={() => this.completeLesson(l)}
					title={completed ? 'Already completed' : canComplete ? 'Mark this lesson complete' : 'Pass the quiz to complete'}>
					{completed ? '✓ Completed' : 'Mark Complete'}
				</button>
				<button onClick={() => this.bookmarkLesson(l)} title='Bookmark this lesson'>
					⭐ Bookmark
				</button>
			</div>
		);
	}

	private async completeLesson(l: Lesson) {
		await this.saveProgress({ completed: [l.Id] });
		this.autoAdvance();
	}

	private async bookmarkLesson(l: Lesson) {
		await this.saveProgress({ bookmarkLessonId: l.Id });
	}

	private autoAdvance() {
		const { activeModuleId, activeLessonId, lessonsByModule } = this.state;
		if (!activeModuleId || !activeLessonId) return;

		const list = lessonsByModule[activeModuleId] || [];
		const idx = list.findIndex((x) => x.Id === activeLessonId);
		const next = idx >= 0 && idx < list.length - 1 ? list[idx + 1] : null;

		if (next) {
			this.setState({ activeLessonId: next.Id });
		} else {
			this.jumpToNextUnlockedModule();
		}
	}

	private jumpToNextUnlockedModule() {
		const { modules, activeModuleId, lessonsByModule } = this.state;
		if (!modules.length || !activeModuleId) return;

		const idx = modules.findIndex((m) => m.Id === activeModuleId);
		for (let i = idx + 1; i < modules.length; i++) {
			const m = modules[i];
			if (this.isModuleUnlocked(m)) {
				const first = (lessonsByModule[m.Id] || [])[0];
				if (first) {
					this.setState({ activeModuleId: m.Id, activeLessonId: first.Id });
					return;
				}
			} else break;
		}
	}

	private isModuleUnlocked(module: Module): boolean {
		const { modules, lessonsByModule } = this.state;
		const index = modules.findIndex((m) => m.Id === module.Id);
		if (index <= 0) return true; // first module is always unlocked
		const prevModules = modules.slice(0, index);
		for (const pm of prevModules) {
			const lessons = lessonsByModule[pm.Id] || [];
			for (const l of lessons) if (!this.isLessonCompleted(l.Id)) return false;
		}
		return true;
	}

	private getVideoPosMap(): { [lessonId: number]: number } {
		const e = this.state.enrollment;
		if (e && e.progress && e.progress.videoPos) {
			return e.progress.videoPos;
		}
		return {};
	}

	private getSavedVideoTime(lessonId: number): number | null {
		const e = this.state.enrollment;
		if (e && e.progress && e.progress.videoPos) {
			const map = e.progress.videoPos;
			if (map.hasOwnProperty(lessonId)) {
				const v = map[lessonId];
				if (typeof v === 'number') return v;
			}
		}
		return null;
	}
}
