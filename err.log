// 1) Resolve the library root folder (by Title) and return its folder object + server-relative path
private async getCourseAssetsRoot() {
  const sp = getSP(this.props.context);
  // Get RootFolder to avoid path guessing
  const lib = await sp.web.lists.getByTitle(COURSE_ASSETS_LIB_TITLE).rootFolder.select('ServerRelativeUrl')();
  const libSrvRel: string = lib.ServerRelativeUrl; // e.g. /sites/lms/CourseAssets
  const rootFolder = sp.web.getFolderByServerRelativePath(libSrvRel);
  return { rootFolder, libSrvRel };
}

// 2) Ensure nested folder path under the library: pass an array of segments (no leading /)
private async ensureNestedFolder(parent: any, segments: string[]): Promise<any> {
  // parent is a Folder instance (e.g., returned by getFolderByServerRelativePath)
  let current = parent;

  for (let i = 0; i < segments.length; i++) {
    const seg = (segments[i] || '').trim();
    if (!seg) continue;

    // Try to get the child folder; if it fails (404), create it under "current"
    try {
      // If exists, just rebind current to that folder
      const child = current.folders.getByName(seg);
      await child.select('ServerRelativeUrl')();
      current = child;
    } catch {
      // Create relative to the *current* folder (NO leading slash here)
      await current.folders.addUsingPath(seg);
      current = current.folders.getByName(seg);
    }
  }

  return current; // final folder
}

// 3) Build your desired folder structure for a lesson (Course/Module nesting is optional)
private buildLessonFolderSegments(lessonId: number): string[] {
  if (!NEST_BY_COURSE_AND_MODULE) return [];
  const lesson = this.state.lessons.find(l => l.Id === lessonId);
  if (!lesson) return [];

  const mod = this.state.modules.find(m => m.Id === lesson.ModuleId);
  const courseId = mod && typeof mod.CourseId === 'number' ? mod.CourseId : null;

  const segs: string[] = ['Courses'];
  if (courseId) segs.push(String(courseId));
  if (mod) segs.push('Modules', String(mod.Id));
  return segs;
}

// 4) Upload API â€” returns absolute + server-relative URLs
private async uploadToLibrary(file: File, lessonId: number): Promise<{ serverRelativeUrl: string; absoluteUrl: string }> {
  const sp = getSP(this.props.context);

  // Resolve web absolute URL for later
  const webInfo: any = await sp.web.select('Url')();
  const webAbs: string = (webInfo.Url || '').replace(/\/+$/, '');

  // Get library root folder
  const { rootFolder, libSrvRel } = await this.getCourseAssetsRoot();

  // Ensure nested folders (relative to the library root)
  const segs = this.buildLessonFolderSegments(lessonId);
  const targetFolder = await this.ensureNestedFolder(rootFolder, segs);

  // Upload the file into the target folder (relative file name only)
  // PnPjs v3:
  if (typeof targetFolder.files.addUsingPath === 'function') {
    const addRes = await targetFolder.files.addUsingPath(file.name, file, { Overwrite: true });
    // Get server-relative URL
    const item = await addRes.file.getItem();
    const props: any = await item.select('FileRef')();
    const serverRelativeUrl: string = props && props.FileRef ? props.FileRef : `${libSrvRel}/${[...segs, file.name].join('/')}`.replace(/\/+/g, '/');
    return { serverRelativeUrl, absoluteUrl: webAbs + serverRelativeUrl };
  }

  // PnPjs v2 fallback:
  // @ts-ignore
  const addResV2 = await targetFolder.files.add(file.name, file, true);
  // @ts-ignore
  const itemV2 = await addResV2.file.getItem();
  // @ts-ignore
  const propsV2: any = await itemV2.select('FileRef')();
  const serverRelativeUrlV2: string = propsV2 && propsV2.FileRef ? propsV2.FileRef : `${libSrvRel}/${[...segs, file.name].join('/')}`.replace(/\/+/g, '/');
  return { serverRelativeUrl: serverRelativeUrlV2, absoluteUrl: webAbs + serverRelativeUrlV2 };
}
private openUploadForLesson = (lessonId: number) => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '*/*';
  input.onchange = async () => {
    if (!input.files || !input.files.length) return;
    try {
      const file = input.files[0];
      const { absoluteUrl } = await this.uploadToLibrary(file, lessonId);

      // Auto-set type by extension if you like (optional)
      // const kind = this.kindFromFilename(file.name) || existingKind;

      // Update row in-memory and mark as updated
      this.setState(s => {
        const idx = s.lessons.findIndex(l => l.Id === lessonId);
        if (idx < 0) return s;
        const updated = { ...s.lessons[idx], ContentUrl: absoluteUrl /*, ContentTypeChoice: kind*/ };
        const lessons = s.lessons.slice();
        lessons[idx] = updated;
        const updLessons = upsertById(s.updLessons, updated);
        return { lessons, updLessons };
      });

      DevExpress.ui.notify('File uploaded and URL set.', 'success', 2000);
    } catch (err) {
      // Helpful diagnostics for 404s
      const msg = (err && (err as any).message) ? (err as any).message : String(err);
      DevExpress.ui.notify('Upload failed: ' + msg, 'error', 3000);
      // console.error(err);
    }
  };
  input.click();
};
