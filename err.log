using System;
using System.Configuration;
using System.Net;
using System.Threading.Tasks;
using System.Web.Http;
using webApi.Models.Floward;
using webApi.Services.Floward;

namespace webApi.Controllers
{
	[RoutePrefix("api/floward")]
	public class FlowardController : ApiController
	{
		private readonly IGiftCardGatewayClient _client;
		private readonly int _clientId;
		private readonly string _tracingId;

		public FlowardController()
		{
			
			_client = new GiftCardGatewayClient();
			_clientId = int.Parse(ConfigurationManager.AppSettings["ChannelID"]);
			_tracingId = $"{_clientId}-${DateTime.Now.ToString("yyyyMMdd-HHmmss.fff")}";
		}

		#region Gift Card Details - Rest : Calling api/floward/{param}
		[HttpGet]
		[Route("{civilId}")]
		public async Task<IHttpActionResult> GetGiftCardDetailsByCivilID(string civilId)
		{
			if (string.IsNullOrEmpty(civilId)) return BadRequest("CivilId is required.");
			if (civilId.Length != 12) return BadRequest("civilId should be 12 digits only.");

			for (int i = 0; i < civilId.Length; i++)
			{
				if (!char.IsDigit(civilId[i])) return BadRequest("civilId should contain digits only.");
			}

			var path = ConfigurationManager.AppSettings["GiftCardApiPath"] ?? "/cms/giftcard/inquire";

			try
			{
				var req = new  GiftCardInquireRequest
				{
					ClientId = _clientId,
					TracingId = _tracingId,
					CivilId = civilId
				};

				var result = await _client.PostAsync<GiftCardInquireRequest,GiftCardInquireResponse>(path,req).ConfigureAwait(false);

				if (result == null)
					return Content(HttpStatusCode.BadGateway, "Empty Response from GW");

				return Ok(result);
			}
			catch (ArgumentException ex)
			{
				return Content(HttpStatusCode.BadRequest, new { message = ex.Message });
			}
			catch (Exception ex)
			{
				return Content(HttpStatusCode.BadGateway, new { message = "Error while calling gift card API", detail = ex.ToString() });
			}
		}
		#endregion

		#region Gift Card Full Refund - Rest : Calling api/floward/refund/full
		[HttpPost]
		[Route("refund/full")]
		public async Task<IHttpActionResult> FullRefund(GiftCardRefundRequestDto req)
		{
			if (req == null) return BadRequest("Body is required");
			if (string.IsNullOrWhiteSpace(req.CardExid)) return BadRequest("CardExid is required");
			if (string.IsNullOrWhiteSpace(req.UserId)) return BadRequest("userId is required");

			var path = ConfigurationManager.AppSettings["GiftCardRefundPath"] ?? "/cms/giftcard/initiateRefund";

			try
			{
				var gwReq = new GiftCardRefundRequest
				{
					clientId = _clientId,
					tracingId = _tracingId,
					cardExid = req.CardExid,
					userId = req.UserId
				};

				var resp = await _client.PostAsync<GiftCardRefundRequest, GiftCardRefundResponse>(path, gwReq);

				return Ok(resp);
			}
			catch (Exception ex)
			{
				return Content(HttpStatusCode.BadGateway, new
				{
					message = "Error while calling Gift Refund API",
					detail = ex.ToString()
				});
			}
		}
		#endregion

		#region Gift Card Partial Refund - Rest : Calling api/floward/refund/raiseclaim
		[HttpPost]
		[Route("refund/raiseclaim")]
		public async Task<IHttpActionResult> RaiseClaim(GiftCardClaimRequest req)
		{

			if (req == null) return BadRequest("Body is required");
			if (req.amount <= 0) return BadRequest("Invalid refund anount");
			if (string.IsNullOrWhiteSpace(req.cardExid)) return BadRequest("CardExid is required");
			if (string.IsNullOrWhiteSpace(req.userId)) return BadRequest("UserId is required");
			if (string.IsNullOrWhiteSpace(req.claimReference)) return BadRequest("Claim Reference is required");

			var path = ConfigurationManager.AppSettings["GiftCardRaiseClaim"] ?? "/cms/giftcard/raiseClaim";

			try
			{
				var gwReq = new GiftCardClaimRequest
				{
					clientId = _clientId,
					tracingId = _tracingId,
					cardExid = req.cardExid,
					amount = req.amount,
					claimReference = req.claimReference,
					userId = req.userId
				};

				var resp = await _client.PostAsync<GiftCardClaimRequest, GiftCardClaimResponse>(path, gwReq);

				return Ok(resp);
			}
			catch (Exception ex)
			{
				return Content(HttpStatusCode.BadGateway, new
				{
					message = "Error while calling Gift Raise Cliam API",
					detail = ex.ToString()
				});
			}
		}
		#endregion
	}
}



===============================================

import * as React from "react";
import { SharePointCaseService } from "../../common";
import { mapNintexOutcomeToCaseStatus } from "../../common/CaseStatusCalculator";
import NintexWorkflowService from "../../common/NintexWorkflowService";
import { INintexOutcome, INintexTask } from "../../models/INintexTask";

export interface IProps {
  nintexSvc: NintexWorkflowService;
  caseSvc: SharePointCaseService;
  listName: string;
  itemId: number;
  onActionCompleted: () => void;
}

export interface IState {
  loading: boolean;
  task: INintexTask | null;
  outcomes: INintexOutcome[];
  selectedOutcome?: INintexOutcome;
  comment: string;
  submitting: boolean;
  error?: string;
}

export default class WorkflowActionPanel extends React.Component<IProps, IState> {
  constructor(props: IProps) {
    super(props);

    this.state = {
      loading: true,
      task: null,
      outcomes: [],
      comment: "",
      submitting: false
    };
  }

  public componentDidMount(): void {
    this.loadTask();
  }

  public render(): React.ReactElement<any> {
    if (this.state.loading) {
      return <div>Loading workflow actions...</div>;
    }

    if (!this.state.task) {
      return null;
    }

    return (
      <div
        style={{
          marginTop: 20,
          padding: 12,
          border: "1px solid #ddd",
          background: "#fafafa"
        }}>
        <h4>Workflow Actions</h4>

        <div style={{ marginBottom: 8 }}>
          {this.state.outcomes.map((o) => (
            <button
              key={o.id}
              onClick={() => this.setState({ selectedOutcome: o })}
              style={{
                marginRight: 8,
                padding: "6px 12px",
                background: this.state.selectedOutcome && this.state.selectedOutcome.id === o.id ? "#0078d4" : "#e0e0e0",
                color: this.state.selectedOutcome && this.state.selectedOutcome.id === o.id ? "#fff" : "#000",
                border: "none"
              }}>
              {o.name}
            </button>
          ))}
        </div>

        {this.state.selectedOutcome && this.state.selectedOutcome.commentMode !== "None" && (
          <div style={{ marginTop: 10 }}>
            <div>
              <b>Comment</b>
            </div>
            <textarea value={this.state.comment} onChange={(e) => this.setState({ comment: (e.target as HTMLTextAreaElement).value })} style={{ width: "100%", minHeight: 70 }} />
          </div>
        )}

        <div style={{ marginTop: 12 }}>
          {this.state.error && (
            <div
              style={{
                marginTop: 10,
                marginBottom: 10,
                padding: "8px 10px",
                background: "#fdecea",
                color: "#b00020",
                border: "1px solid #f5c6cb",
                borderRadius: 4,
                fontSize: 13
              }}>
              {this.state.error}
            </div>
          )}
          <button
            disabled={this.state.submitting || !this.state.selectedOutcome}
            onClick={async () => {
              if (!this.validateBeforeSubmit(this.state.selectedOutcome)) {
                return;
              }
              await this.submit();
            }}
            style={{
              padding: "8px 16px",
              background: "#0078d4",
              color: "#fff",
              border: "none"
            }}>
            {this.state.submitting ? "Processing..." : "Submit"}
          </button>
        </div>
      </div>
    );
  }

  private async loadTask(): Promise<void> {
    try {
      const task = await this.props.nintexSvc.getRunningTask(this.props.listName, this.props.itemId);

      if (!task || task.taskType !== "MultiOutcome") {
        this.setState({ loading: false, task: null });
        return;
      }

      const outcomes = await this.props.nintexSvc.getFlexiTaskOutcomes(task.sharePointTaskId, task.taskListName);

      this.setState({
        loading: false,
        task: task,
        outcomes: outcomes
      });
    } catch (e) {
      this.setState({
        loading: false,
        error: "Failed to load workflow task."
      });
    }
  }

  private validateBeforeSubmit(outcome: INintexOutcome): boolean {
    if (outcome.commentMode === "Required" && !this.state.comment && !this.state.comment.trim()) {
      this.setState({
        error: "Comment is required for this action."
      });
      return false;
      // alert("Comment is madatory for this action.");
      // return false;
    }

    this.setState({ error: undefined });
    return true;
  }

  private submit = async (): Promise<void> => {
    const t = this.state.task;
    const o = this.state.selectedOutcome;

    if (!t || !o) {
      return;
    }

    if (o.commentMode === "Required" && !this.state.comment) {
      alert("Comment is required.");
      return;
    }

    this.setState({ submitting: true });

    try {
      const caseStatus = mapNintexOutcomeToCaseStatus(o.name);

      if (caseStatus) {
        await this.props.caseSvc.updateCaseStatus(this.props.itemId, caseStatus, o.name);
      }

      await this.props.nintexSvc.completeTaskWithHistory({
        task: this.state.task,
        outcome: o.name,
        comment: this.state.comment,
        caseItemId: this.props.itemId
      });

      this.setState({
        comment: ""
      });
      this.props.onActionCompleted();
    } catch (e) {
      alert("Workflow action failed.");
    } finally {
      this.setState({ submitting: false });
    }
  };
}


