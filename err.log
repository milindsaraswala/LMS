import * as React from "react";
import { apiGet, apiPost } from "./common/ApiClient";
import { DISPUTE_REASONS, isAttachmentRequired } from "./common/DisputeReasons";
import { SharePointDisputeService } from "./common/SharePointDisputeService";
import CustomerLookup from "./customer/CustomerLookup";
import { ICustomerCard, ICustomerInfo, ICustomerLookupResult } from "./customer/ICustomerInfo";
import { IDisputeTransaction, IExistingDisputeRow } from "./models/IDisputeTransaction";

export type UiStatus = "idle" | "customerFound" | "starting" | "waiting" | "approved" | "rejected" | "failed" | "timeout";

export interface IProps {
  apiBaseUrl: string;
  spHttpClient: any;
  siteUrl: string;
  listTitle: string;
}

export interface IState {
  status: UiStatus;

  customer?: ICustomerInfo;
  cards?: ICustomerCard[];

  message?: string;

  // PACI
  requestId?: string;
  secondsLeft: number;
  resultCode?: number;
  resultDescription?: string;

  transactions: IDisputeTransaction[];
  submittedRows?: IExistingDisputeRow[];

  loadingExisting: boolean;
  existingRows: IExistingDisputeRow[];

  submitting?: boolean;
  mockPaci: boolean;

  isNewCase: boolean;
  currentCaseId?: string;
}

export default class FlowardClaim extends React.Component<IProps, IState> {
  private pollTimer?: number;
  private countdownTimer?: number;

  private spSvc: SharePointDisputeService;

  constructor(props: IProps) {
    super(props);

    this.spSvc = new SharePointDisputeService(props.spHttpClient, props.siteUrl, props.listTitle);

    this.state = {
      status: "idle",
      secondsLeft: 300,
      transactions: [],
      loadingExisting: false,
      existingRows: [],
      submitting: false,
      mockPaci: true, // Mocking Authentication
      isNewCase: false,
      submittedRows: [],
      currentCaseId: undefined
    };
  }

  public componentWillUnmount(): void {
    this.clearTimers();
  }

  public render(): React.ReactElement<IProps> {
    const { customer, cards, status, message, secondsLeft, requestId, transactions, existingRows, loadingExisting, submitting } = this.state;

    const canAddTransaction = this.state.status === "approved" && this.state.isNewCase === true;

    return (
      <div style={{ padding: 12, maxWidth: 1000 }}>
        <CustomerLookup apiBaseUrl={this.props.apiBaseUrl} onCustomerFound={this.onCustomerFound} onCustomerNotFound={this.onCustomerNotFound} />

        {customer && (
          <div style={{ marginTop: 12, border: "1px solid #ddd", padding: 12, borderRadius: 4 }}>
            <div style={{ marginBottom: 8 }}>
              <b>Customer:</b> {customer.fullNameEn} / {customer.fullNameAr}
            </div>
            <div style={{ marginBottom: 8 }}>
              <b>Civil ID</b> {customer.civilId}
            </div>

            <div style={{ marginTop: 10 }}>
              <label>
                <input type="checkbox" checked={this.state.mockPaci} onChange={(e) => this.setState({ mockPaci: (e.target as HTMLInputElement).checked })} /> Mock PACI Approval
                (testing)
              </label>
            </div>
            <button
              onClick={() => this.startPaciAuth()}
              disabled={status === "starting" || status === "waiting" || (existingRows.length > 0 && !this.state.isNewCase)}
              style={{ padding: "8px 14px" }}>
              Authenticate with PACI
            </button>

            {status === "waiting" && (
              <div style={{ marginTop: 10 }}>
                <div>
                  <b>RequestId:</b> {requestId}
                </div>
                <div>
                  <b>Time left:</b> {secondsLeft}s
                </div>
              </div>
            )}

            {message && <div style={{ marginTop: 10 }}>{message}</div>}

            {/* Existing transactions */}
            {existingRows.length > 0 && (
              <div
                style={{
                  background: "#fff3cd",
                  border: "1px solid #ffeeba",
                  padding: 8,
                  marginTop: 10,
                  marginBottom: 10,
                  fontSize: 13
                }}>
                This customer already has <b>{existingRows.length}</b> previous case(s).
              </div>
            )}
            {
              /*!this.state.isNewCase && (!this.state.submittedRows || this.state.submittedRows.length === 0) &&*/ existingRows.length > 0 && (
                <div style={{ marginTop: 14 }}>
                  <h4 style={{ margin: "10px 0" }}>Previous Transactions</h4>
                  {loadingExisting ? <div>Loading previous transactions...</div> : this.renderExistingTable(existingRows)}
                  <div style={{ marginTop: 10, color: "#b00020", fontWeight: 600 }}>This customer has previous case(s). You may proceed to create new case.</div>
                </div>
              )
            }

            {this.state.submittedRows && this.state.submittedRows.length > 0 && (
              <div style={{ marginTop: 16 }}>
                <h4>Current Case (Just Create)</h4>
                {this.renderExistingTable(this.state.submittedRows)}
              </div>
            )}

            {existingRows.length > 0 && !this.state.isNewCase && (!this.state.submittedRows || this.state.submittedRows.length === 0) && (
              <div style={{ marginTop: 12 }}>
                <button
                  onClick={() =>
                    this.setState({
                      isNewCase: true,
                      currentCaseId: this.generateCaseId(),
                      transactions: [],
                      requestId: undefined,
                      status: "idle",
                      message: "New Case started. Please authenticate customer."
                    })
                  }
                  style={{ padding: "8px 14px" }}>
                  Create New Case
                </button>
              </div>
            )}

            {/* After PACI approval - allow adding multiple transactions */}
            {canAddTransaction && this.state.cards && this.state.cards.length > 0 && (
              <div style={{ marginTop: 14, borderTop: "1px solid #eee", paddingTop: 12 }}>
                <h4 style={{ marginTop: 0 }}>Add Transactions</h4>

                <button onClick={this.addTransactionRow} style={{ padding: "6px 12px" }}>
                  + Add Transaction
                </button>

                {transactions.length === 0 && <div style={{ marginTop: 10 }}>No transactions added yet.</div>}

                {transactions.map((t) => this.renderTransactionRow(t, cards))}

                <div style={{ marginTop: 12 }}>
                  <button onClick={this.submitToSharePoint} disabled={submitting || transactions.length === 0} style={{ padding: "8px 14px" }}>
                    {submitting ? "Submitting..." : "Submit"}
                  </button>
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    );
  }

  private renderExistingTable(rows: IExistingDisputeRow[]): React.ReactElement<any> {
    if (!rows || rows.length === 0) {
      return <div>No previous transactions found.</div>;
    }

    return (
      <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 12 }}>
        <thead>
          <tr>
            <th style={th}>ID</th>
            <th style={th}>Status</th>
            <th style={th}>Card</th>
            <th style={th}>Date</th>
            <th style={th}>Time</th>
            <th style={th}>Amount</th>
            <th style={th}>Merchant</th>
            <th style={th}>Reason</th>
            <th style={th}>Created</th>
          </tr>
        </thead>
        <tbody>
          {rows.map((r) => (
            <tr key={r.id}>
              <td style={td}>{r.id}</td>
              <td style={td}>{r.status || ""}</td>
              <td style={td}>{r.cardMasked || ""}</td>
              <td style={td}>{this.formatDate(r.txnDate) || ""}</td>
              <td style={td}>{this.formatTime(r.txnTime) || ""}</td>
              <td style={td}>{r.txnAmount !== undefined ? r.txnAmount : ""}</td>
              <td style={td}>{r.merchantName || ""}</td>
              <td style={td}>{this.getDisputeReasonText(r.disputeReason) || ""}</td>
              <td style={td}>{this.formatDate(r.created) || ""}</td>
            </tr>
          ))}
        </tbody>
      </table>
    );
  }

  private renderTransactionRow(t: IDisputeTransaction, cards: ICustomerCard[]): React.ReactElement<any> {
    const attachmentNeeded = isAttachmentRequired(t.disputeReason);
    const rowError = this.validateOneTransaction(t);

    return (
      <div key={t.localId} style={{ marginTop: 12, border: "1px solid #ddd", padding: 12, borderRadius: 4 }}>
        <div style={{ display: "flex", justifyContent: "space-between", gap: 8 }}>
          <b>Transaction</b>
          <button onClick={() => this.removeTransactionRow(t.localId)} style={{ padding: "4px 10px" }}>
            Remove
          </button>
        </div>

        {rowError && <div style={{ marginTop: 6, color: "#b00020" }}>{rowError}</div>}

        <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 10, marginTop: 10 }}>
          <div>
            <div>
              <b>Card</b>
            </div>
            {/* <pre style={{ fontSize: 11 }}>{JSON.stringify(cards, null, 2)}</pre> */}
            <select
              value={t.cardNo || ""}
              onChange={(e) => this.updateTransaction(t.localId, { cardNo: (e.target as HTMLSelectElement).value })}
              style={{ padding: 8, width: "100%" }}>
              <option value="">-- Select card --</option>
              {cards.map((c) => (
                <option key={c.cardNo} value={c.cardNo}>
                  {c.maskedCardNo || c.cardNo}
                </option>
              ))}
            </select>
          </div>

          <div>
            <div>
              <b>Dispute Reason</b>
            </div>
            <select
              value={t.disputeReason || ""}
              onChange={(e) => this.updateTransaction(t.localId, { disputeReason: (e.target as HTMLSelectElement).value })}
              style={{ padding: 8, width: "100%" }}>
              {DISPUTE_REASONS.map((r) => (
                <option key={r.key} value={r.key}>
                  {r.text}
                </option>
              ))}
            </select>
            {attachmentNeeded && (
              <div style={{ fontSize: 12, marginTop: 4 }}>
                <b>Attachment is required</b> for this reason.
              </div>
            )}
          </div>

          <div>
            <div>
              <b>Transaction Date</b>
            </div>
            <input
              type="date"
              value={t.txnDate || ""}
              onChange={(e) => this.updateTransaction(t.localId, { txnDate: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div>
            <div>
              <b>Transaction Time</b>
            </div>
            <input
              type="time"
              value={t.txnTime || ""}
              onChange={(e) => this.updateTransaction(t.localId, { txnTime: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div>
            <div>
              <b>Transaction Amount</b>
            </div>
            <input
              type="text"
              value={t.txnAmount || ""}
              onChange={(e) => {
                const v = (e.target as HTMLInputElement).value;
                if (/^\d*\.?\d*$/.test(v)) {
                  this.updateTransaction(t.localId, { txnAmount: v });
                }
              }}
              placeholder="e.g. 12.500"
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div>
            <div>
              <b>Merchant Name</b>
            </div>
            <input
              type="text"
              value={t.merchantName || ""}
              onChange={(e) => this.updateTransaction(t.localId, { merchantName: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div style={{ gridColumn: "1 / span 2" }}>
            <div>
              <b>Comment</b>
            </div>
            <textarea
              value={t.comment || ""}
              onChange={(e) => this.updateTransaction(t.localId, { comment: (e.target as HTMLTextAreaElement).value })}
              style={{ padding: 8, width: "100%", minHeight: 70 }}
            />
          </div>

          <div style={{ gridColumn: "1 / span 2" }}>
            <div>
              <b>Attachment {attachmentNeeded ? "(Required)" : "(Optional)"}</b>
            </div>
            <input
              type="file"
              onChange={(e) => {
                const files = (e.target as HTMLInputElement).files;
                this.updateTransaction(t.localId, { attachment: files && files.length > 0 ? files[0] : null });
              }}
            />
            {t.attachment && <div style={{ fontSize: 12, marginTop: 4 }}>{t.attachment.name}</div>}
          </div>
        </div>
      </div>
    );
  }

  private clearTimers(): void {
    if (this.pollTimer !== undefined) {
      window.clearInterval(this.pollTimer);
      this.pollTimer = undefined;
    }
    if (this.countdownTimer !== undefined) {
      window.clearInterval(this.countdownTimer);
      this.countdownTimer = undefined;
    }
  }

  private onCustomerFound = async (result: ICustomerLookupResult): Promise<void> => {
    this.clearTimers();
    this.setState({
      customer: result.customer,
      cards: result.cards,
      status: "customerFound",
      message: undefined,
      requestId: undefined,
      secondsLeft: 300,
      resultCode: undefined,
      resultDescription: undefined,
      transactions: [],
      loadingExisting: true,
      existingRows: [],
      isNewCase: false
    });

    // load existing disputes for civilId
    try {
      const rows = await this.spSvc.getExistingByCivilId(result.customer.civilId);
      this.setState({ existingRows: rows, loadingExisting: false });
    } catch (e) {
      this.setState({
        existingRows: [],
        loadingExisting: false,
        message: "Failed to load previous transactions: " + (e && (e as any).message ? (e as any).message : "")
      });
    }
  };

  private onCustomerNotFound = (msg: string) => {
    this.clearTimers();
    this.setState({
      customer: undefined,
      cards: undefined,
      status: "idle",
      message: msg,
      requestId: undefined,
      secondsLeft: 300,
      resultCode: undefined,
      resultDescription: undefined,
      transactions: [],
      existingRows: [],
      loadingExisting: false
    });
  };

  private async startPaciAuth(): Promise<void> {
    const customer: ICustomerInfo = this.state.customer;
    if (!customer || !customer.civilId) {
      this.setState({ status: "failed", message: "Please lookup valid Civil ID first." });
      return;
    }

    // MOCK MODE (temporary)
    if (this.state.mockPaci) {
      this.clearTimers();

      const fakeRequestId = "MOCK - " + new Date().getTime();

      this.setState({
        status: "approved",
        requestId: fakeRequestId,
        currentCaseId: this.state.currentCaseId || this.generateCaseId(),
        isNewCase: true,
        resultCode: 10,
        resultDescription: "Authenticated (Mock)",
        message: "PACI Approved (Mock mode)",
        secondsLeft: 300
      });

      return;
    }

    // REAL PACI
    this.clearTimers();
    this.setState({ status: "starting", message: "Sending PACI authentication request...", secondsLeft: 300 });
    try {
      const url: string = this.props.apiBaseUrl.replace(/\/$/, "") + "/api/paci/initiate-auth";

      const resp = await apiPost<{ requestId: string }>(url, {
        authenticationReasonAr: "الحصول على تفويض العميل لتحديث بيانات البطاقة المدنية",
        authenticationReasonEn: "Get Customer Approval to update Civil Details",
        civilNo: customer.civilId,
        assuranceLevel: "Medium",
        serviceDescriptionEN: "Refund claim for a Gift Card",
        serviceDescriptionAR: "طلب استرداد مبلغ لبطاقة الهدايا",
        additionalData: "",
        challenge: ""
      });

      if (!resp || !resp.requestId) {
        this.setState({ status: "failed", message: "No RequestId returned from PACI initiate API." });
        return;
      }

      this.setState({ status: "waiting", requestId: resp.requestId, message: "Waiting for customer approval..." });

      this.startCountdown(resp.requestId);
      this.startPolling(resp.requestId);
    } catch (e) {
      this.setState({ status: "failed", message: e && (e as any).message ? (e as any).message : "Failed to initiate PACI auth." });
    }
  }

  private startCountdown(requestId: string) {
    this.countdownTimer = window.setInterval(() => {
      this.setState((prev) => {
        const next = prev.secondsLeft - 1;
        if (next <= 0) {
          this.clearTimers();
          return { ...prev, secondsLeft: 0, status: "timeout", message: "Timed out (5 minutes). No response received." };
        }
        return { ...prev, secondsLeft: next };
      });
    }, 1000);
  }

  private startPolling(requestId: string) {
    this.pollTimer = window.setInterval(async () => {
      try {
        const url = this.props.apiBaseUrl.replace(/\/$/, "") + "/api/paci/status/" + encodeURIComponent(requestId);

        const s = await apiGet<{
          requestId: string;
          isProcessed: boolean;
          resultCode?: number;
          resultDescription?: string;
        }>(url);

        if (!s || !s.isProcessed) {
          return;
        }

        this.clearTimers();

        const rc: number = s.resultCode;
        const desc: string = s.resultDescription;

        if (rc === 10) {
          this.setState({
            status: "approved",
            currentCaseId: this.state.currentCaseId || this.generateCaseId(),
            resultCode: rc,
            resultDescription: desc,
            message: desc || "Authenticated"
          });
        } else if (rc === 40) {
          this.setState({ status: "rejected", resultCode: rc, resultDescription: desc, message: desc || "Declined" });
        } else {
          this.setState({ status: "failed", resultCode: rc, resultDescription: desc, message: desc || "Failed" });
        }
      } catch (err) {
        // keep polling quietly
      }
    }, 3000);
  }

  private addTransactionRow = (): void => {
    const id = "t_" + new Date().getTime() + "_" + Math.floor(Math.random() * 1000);

    const next: IDisputeTransaction = { localId: id, attachment: null };
    this.setState((prev) => ({
      transactions: prev.transactions.concat([next])
    }));
  };

  private removeTransactionRow = (localId: string): void => {
    this.setState((prev) => ({
      transactions: prev.transactions.filter((x) => x.localId !== localId)
    }));
  };

  private updateTransaction = (localId: string, patch: Partial<IDisputeTransaction>): void => {
    this.setState((prev) => ({
      transactions: prev.transactions.map((x) => (x.localId === localId ? { ...x, ...patch } : x))
    }));
  };

  private validateOneTransaction(t: IDisputeTransaction): string | null {
    if (!t.cardNo) {
      return "Card is required.";
    }
    if (!t.txnDate) {
      return "Transaction date is required.";
    }
    if (!t.txnTime) {
      return "Transaction time is required.";
    }
    if (!t.txnAmount || isNaN(Number(t.txnAmount))) {
      return "Valid amount is required.";
    }
    if (!t.merchantName) {
      return "Merchant name is required.";
    }
    if (!t.disputeReason) {
      return "Dispute reason is required.";
    }

    if (isAttachmentRequired(t.disputeReason) && !t.attachment) {
      return "Attachment is required for selected dispute reason.";
    }

    return null;
  }

  private validateAll(): string | null {
    if (this.state.status !== "approved") {
      return "PACI must be approved before submitting.";
    }
    if (!this.state.customer) {
      return "Customer is missing.";
    }
    if (!this.state.requestId) {
      return "PACI RequestId is missing.";
    }
    if (!this.state.transactions || this.state.transactions.length === 0) {
      return "Please add at least one transaction.";
    }

    for (let i = 0; i < this.state.transactions.length; i++) {
      const err = this.validateOneTransaction(this.state.transactions[i]);
      if (err) {
        return "Row " + (i + 1) + ": " + err;
      }
    }

    return null;
  }

  private submitToSharePoint = async (): Promise<void> => {
    const err = this.validateAll();
    if (err) {
      this.setState({ message: err });
      return;
    }

    if (!this.state.currentCaseId) {
      throw new Error("CaseId is missing. Cannot submit case.");
    }

    const customer = this.state.customer!;
    const paciRequestId = this.state.requestId!;
    const cards = this.state.cards || [];
    const caseId = this.state.currentCaseId;

    const submitted: IExistingDisputeRow[] = [];

    this.setState({ submitting: true, message: "Submitting to SharePoint..." });

    try {
      for (let i = 0; i < this.state.transactions.length; i++) {
        const t = this.state.transactions[i];

        // get masked card
        let masked = "";
        for (let c = 0; c < cards.length; c++) {
          if (cards[c].cardNo === t.cardNo) {
            masked = cards[c].maskedCardNo;
            break;
          }
        }

        const itemId = await this.spSvc.addDisputeItem({
          civilId: customer.civilId,
          caseId: caseId,
          paciRequestId: paciRequestId,
          cardNo: t.cardNo!,
          maskedCardNo: masked,
          txnDate: t.txnDate!,
          txnTime: t.txnTime!,
          txnAmount: Number(t.txnAmount),
          merchantName: t.merchantName!,
          disputeReason: t.disputeReason!,
          comment: t.comment || ""
        });

        submitted.push({
          id: itemId,
          caseId: caseId,
          civilId: customer.civilId,
          status: "New",
          cardMasked: masked,
          txnDate: t.txnDate!,
          txnTime: t.txnTime!,
          txnAmount: Number(t.txnAmount),
          merchantName: t.merchantName!,
          disputeReason: t.disputeReason!,
          created: new Date().toISOString()
        });

        if (t.attachment) {
          await this.spSvc.addAttachment(itemId, t.attachment);
        }
      }

      // refresh existing table
      // const allRows = await this.spSvc.getExistingByCivilId(customer.civilId);
      // const currentCaseRows = allRows.filter((r) => r.caseId === this.state.currentCaseId);
      // const previousRows = allRows.filter((r) => r.caseId !== this.state.currentCaseId);

      this.setState({
        submitting: false,
        message: "Case created successfully.",
        transactions: [],
        submittedRows: submitted,
        isNewCase: false,
        status: "customerFound"
      });
    } catch (e) {
      this.setState({
        submitting: false,
        message: "Submit failed: " + (e && (e as any).message ? (e as any).message : e ? e.toString() : "")
      });
    }
  };

  private formatDate = (dateStr?: string): string => {
    if (!dateStr) {
      return "";
    }
    const d = new Date(dateStr);
    return d.toLocaleString("en-GB", {
      day: "2-digit",
      month: "short",
      year: "numeric"
    });
  };

  private formatTime = (timeStr?: string): string => {
    if (!timeStr) {
      return "";
    }

    const [h, m] = timeStr.split(":").map(Number);
    const d = new Date();
    d.setHours(h, m, 0, 0);
    return d.toLocaleTimeString("en-US", {
      hour: "2-digit",
      minute: "2-digit",
      hour12: true
    });
  };

  private getDisputeReasonText = (key?: string): string => {
    if (!key) {
      return "";
    }

    for (let i = 0; i < DISPUTE_REASONS.length; i++) {
      if (DISPUTE_REASONS[i].key === key) {
        return DISPUTE_REASONS[i].text;
      }
    }

    return key;
  };

  private generateCaseId(): string {
    return `FLW-${new Date().getFullYear()}-${Date.now()}`;
  }
}
const th: React.CSSProperties = { borderBottom: "1px solid #ddd", textAlign: "left", padding: 6 };
const td: React.CSSProperties = { borderBottom: "1px solid #f0f0f0", padding: 6, verticalAlign: "top" };
