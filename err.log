import { WebPartContext } from "@microsoft/sp-webpart-base";
import * as React from "react";
import { apiGet, apiPost, decodeString, DISPUTE_REASONS, encodeString, getCleanUserId, isAttachmentRequired, SharePointCaseService } from "../../../common";
import { TransactionStatus } from "../../../common/CaseStatus";
import { calculateCaseStatusFromTransactions } from "../../../common/CaseStatusCalculator";
import NintexWorkflowService from "../../../common/NintexWorkflowService";
import { SharePointDisputeService } from "../../../common/SharePointDisputeService";
import CustomerLookup, { ICustomerCard, ICustomerInfo, ICustomerLookupResult } from "../../../components/customer";
import CaseDashboard from "../../../components/dashboard/CaseDashboard";
import CaseActionHistoryPanel from "../../../components/workflow/CaseHistoryPanel";
import WorkflowActionPanel from "../../../components/workflow/WorkflowActionPanel";
import { IDisputeTransaction, IExistingDisputeRow } from "../../../models/IDisputeTransaction";

export type UiStatus = "idle" | "customerFound" | "starting" | "waiting" | "approved" | "rejected" | "failed" | "timeout";

export interface IProps {
  apiBaseUrl: string;
  spHttpClient: any;
  siteUrl: string;
  listTitle: string;
  context: WebPartContext;
}

export interface IState {
  status: UiStatus;

  customer?: ICustomerInfo;
  cards?: ICustomerCard[];

  message?: string;

  // PACI
  requestId?: string;
  secondsLeft: number;
  resultCode?: number;
  resultDescription?: string;

  transactions: IDisputeTransaction[];
  currentCaseRows?: IExistingDisputeRow[];

  loadingExisting: boolean;
  previousCaseRows: IExistingDisputeRow[];

  submitting?: boolean;
  mockPaci: boolean;

  isNewCase: boolean;
  currentCaseId?: string;
  caseItemId?: number;

  isCaseLocked: boolean;

  view: "dashboard" | "newCase" | "openCase";
  selectedCaseId?: number;

  showCommentModal?: boolean;
  selectedComment?: string;

  caseStatus?: string;

  // block card for agent
  payuInProgress?: boolean;
}

export default class FlowardClaim extends React.Component<IProps, IState> {
  private pollTimer?: number;
  private countdownTimer?: number;

  private spSvc: SharePointDisputeService;
  private caseSvc: SharePointCaseService;
  private nintexSvc: NintexWorkflowService;

  constructor(props: IProps) {
    super(props);

    this.spSvc = new SharePointDisputeService(props.spHttpClient, props.siteUrl, props.listTitle);
    this.caseSvc = new SharePointCaseService(props.spHttpClient, props.siteUrl, "DisputeCases");
    this.nintexSvc = new NintexWorkflowService(props.context);

    this.state = {
      status: "idle",
      secondsLeft: 300,
      transactions: [],
      loadingExisting: false,
      previousCaseRows: [],
      submitting: false,
      mockPaci: true, // Mocking Authentication
      isNewCase: false,
      currentCaseRows: [],
      currentCaseId: undefined,
      isCaseLocked: false,

      view: "dashboard",
      selectedCaseId: undefined
    };
  }

  public componentWillUnmount(): void {
    this.clearTimers();
  }

  public async componentDidMount() {
    const params = new URLSearchParams(window.location.search);
    const encoded = params.get("c");

    if (encoded) {
      try {
        const decoded = decodeString(encoded);
        const caseItemId = parseInt(decoded, 10);

        if (!isNaN(caseItemId)) {
          await this.openExistingCase(caseItemId);
          return;
        }
      } catch (e) {
        console.warn("Invalid case link");
      }
    }
  }

  public render(): React.ReactElement<IProps> {
    const { view } = this.state;

    return (
      <div style={{ padding: 12, maxWidth: 1200 }}>
        {view === "dashboard" && this.renderDashboard()}
        {view !== "dashboard" && this.renderCaseScreen()}
      </div>
    );
  }

  private renderDashboard(): React.ReactElement<any> {
    return (
      <div>
        <div style={{ display: "flex", justifyContent: "space-between", marginBottom: 12 }}>
          <h3>Dispute Case Dashboard</h3>
          <button style={{ padding: "8px 14px" }} onClick={this.startNewCase}>
            + Create New Case
          </button>
        </div>

        <CaseDashboard caseSvc={this.caseSvc} onSelectCase={this.openExistingCase} />
      </div>
    );
  }

  private startNewCase = () => {
    this.setState({
      view: "newCase",
      customer: undefined,
      cards: undefined,
      previousCaseRows: [],
      transactions: [],
      currentCaseRows: [],
      currentCaseId: undefined,
      caseItemId: undefined,
      isNewCase: false,
      isCaseLocked: false,
      status: "idle"
    });
  };

  private openExistingCase = async (caseItemId: number) => {
    const caseInfo = await this.caseSvc.getCaseById(caseItemId);
    const rows = await this.spSvc.getByCaseId(caseInfo.caseId);

    const isLocked = caseInfo.status && caseInfo.status !== "New" && caseInfo.status !== "Draft";

    this.setState({
      view: "openCase",
      caseItemId,
      currentCaseId: caseInfo.caseId,
      caseStatus: caseInfo.status || "Pending With Card Operation",
      customer: {
        civilId: caseInfo.civilId,
        fullNameEn: caseInfo.customerName
      } as any,
      previousCaseRows: [],
      currentCaseRows: rows,
      isCaseLocked: isLocked,
      isNewCase: false,
      status: "approved"
    });
  };

  private renderCaseScreen(): React.ReactElement<any> {
    const { customer, cards, status, message, secondsLeft, requestId, transactions, previousCaseRows, loadingExisting, submitting } = this.state;

    const isCreatingCase = this.state.isNewCase === true && this.state.status === "approved";

    return (
      <div>
        <button style={{ marginBottom: 10 }} onClick={() => this.setState({ view: "dashboard" })}>
          Back to Dashboard
        </button>

        {this.state.caseItemId && (
          <div style={{ marginBottom: 12 }}>
            <span
              style={{
                padding: "4px 10px",
                borderRadius: 12,
                fontSize: 12,
                fontWeight: 600,
                color: "#fff",
                background: this.getCaseBadgeColor()
              }}>
              {this.getCaseBadgeText()}
            </span>
          </div>
        )}

        {this.state.view === "newCase" && <CustomerLookup apiBaseUrl={this.props.apiBaseUrl} onCustomerFound={this.onCustomerFound} onCustomerNotFound={this.onCustomerNotFound} />}

        {customer && (
          <div style={{ marginTop: 12, border: "1px solid #ddd", padding: 12, borderRadius: 4 }}>
            <div style={{ marginBottom: 8 }}>
              <b>Customer:</b> {customer.fullNameEn} / {customer.fullNameAr}
            </div>
            <div style={{ marginBottom: 8 }}>
              <b>Civil ID</b> {customer.civilId}
            </div>

            <div style={{ marginTop: 10 }}>
              <label>
                <input type="checkbox" checked={this.state.mockPaci} onChange={(e) => this.setState({ mockPaci: (e.target as HTMLInputElement).checked })} /> Mock PACI Approval
                (testing)
              </label>
            </div>
            <button
              onClick={() => this.startPaciAuth()}
              disabled={status === "starting" || status === "waiting" || (previousCaseRows.length > 0 && !this.state.isNewCase)}
              style={{ padding: "8px 14px" }}>
              Authenticate with PACI
            </button>

            {status === "waiting" && (
              <div style={{ marginTop: 10 }}>
                <div>
                  <b>RequestId:</b> {requestId}
                </div>
                <div>
                  <b>Time left:</b> {secondsLeft}s
                </div>
              </div>
            )}

            {message && <div style={{ marginTop: 10 }}>{message}</div>}

            {/* Existing transactions */}
            {previousCaseRows.length > 0 && (
              <div
                style={{
                  background: "#fff3cd",
                  border: "1px solid #ffeeba",
                  padding: 8,
                  marginTop: 10,
                  marginBottom: 10,
                  fontSize: 13
                }}>
                This customer already has <b>{previousCaseRows.length}</b> previous case(s).
              </div>
            )}
            {previousCaseRows.length > 0 && (
              <div style={{ marginTop: 14 }}>
                <h4 style={{ margin: "10px 0" }}>Previous Transactions</h4>
                {loadingExisting ? <div>Loading previous transactions...</div> : this.renderExistingTable(previousCaseRows)}
                <div style={{ marginTop: 10, color: "#b00020", fontWeight: 600 }}>This customer has previous case(s). You may proceed to create new case.</div>
              </div>
            )}

            {this.state.isCaseLocked && (
              <div
                style={{
                  marginTop: 12,
                  padding: 10,
                  background: "#e7f3ff",
                  border: "1px solid #90caf9",
                  color: "#0d47a1",
                  fontWeight: 600
                }}>
                This case has been submitted for processing and is now read-only.
              </div>
            )}

            {this.state.currentCaseRows && this.state.currentCaseRows.length > 0 && (
              <div style={{ marginTop: 16 }}>
                <h4>Current Case (Just Created)</h4>

                {this.renderExistingTable(this.state.currentCaseRows)}
              </div>
            )}

            {this.state.caseItemId && !this.state.isCaseLocked && Array.isArray(this.state.currentCaseRows) && this.state.currentCaseRows.length > 0 && (
              <div style={{ marginTop: 16, paddingTop: 12, borderTop: "1px solid #ddd" }}>
                <button
                  onClick={this.submitCaseForWorkflow}
                  disabled={this.state.submitting || this.state.payuInProgress === true}
                  style={{
                    padding: "10px 18px",
                    background: "#0078d4",
                    color: "#fff",
                    border: "none",
                    borderRadius: 3,
                    fontWeight: 600
                  }}>
                  Submit Case for Processing
                </button>
              </div>
            )}

            {previousCaseRows.length > 0 && !this.state.isNewCase && (!this.state.currentCaseRows || this.state.currentCaseRows.length === 0) && (
              <div style={{ marginTop: 12 }}>
                <button
                  onClick={() =>
                    this.setState({
                      isNewCase: true,
                      currentCaseId: this.generateCaseId(),
                      transactions: [],
                      currentCaseRows: [],
                      requestId: undefined,
                      status: "idle",
                      message: "New Case started. Please authenticate customer."
                    })
                  }
                  style={{ padding: "8px 14px" }}>
                  Create New Case
                </button>
              </div>
            )}

            {/* After PACI approval - allow adding multiple transactions */}
            {isCreatingCase && !this.state.isCaseLocked && this.state.cards && this.state.cards.length > 0 && (
              <div style={{ marginTop: 14, borderTop: "1px solid #eee", paddingTop: 12 }}>
                <h4 style={{ marginTop: 0 }}>Add Transactions</h4>

                <button onClick={this.addTransactionRow} style={{ padding: "6px 12px" }}>
                  + Add Transaction
                </button>

                {transactions.length === 0 && <div style={{ marginTop: 10 }}>No transactions added yet.</div>}

                {transactions.map((t) => this.renderTransactionRow(t, cards))}

                <div style={{ marginTop: 12 }}>
                  <button onClick={this.submitToSharePoint} disabled={submitting || transactions.length === 0} style={{ padding: "8px 14px" }}>
                    {submitting ? "Submitting..." : "Submit"}
                  </button>
                </div>
              </div>
            )}
          </div>
        )}
        {this.state.view === "openCase" && this.state.caseItemId && this.state.isCaseLocked && (
          <WorkflowActionPanel
            nintexSvc={this.nintexSvc}
            caseSvc={this.caseSvc}
            listName="DisputeCases"
            itemId={this.state.caseItemId}
            onActionCompleted={() => {
              this.setState({
                view: "dashboard",
                message: undefined,
                selectedCaseId: undefined,
                customer: undefined,
                cards: undefined,
                previousCaseRows: [],
                currentCaseRows: [],
                isCaseLocked: false
              });
            }}
          />
        )}
        {this.state.caseItemId && <CaseActionHistoryPanel nintexSvc={this.nintexSvc} caseItemId={this.state.caseItemId} />}

        {this.state.showCommentModal && (
          <div
            style={{
              position: "fixed",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: "rgba(0,0,0,0.4)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              zIndex: 1000
            }}>
            <div
              style={{
                background: "#fff",
                padding: 16,
                width: 450,
                maxHeight: "70%",
                overflowY: "auto",
                borderRadius: 4
              }}>
              <h4>Transaction Comment</h4>

              <div
                style={{
                  whiteSpace: "pre-wrap",
                  marginTop: 8,
                  fontSize: 14
                }}>
                {this.state.selectedComment}
              </div>

              <div style={{ textAlign: "right", marginTop: 16 }}>
                <button
                  onClick={() =>
                    this.setState({
                      showCommentModal: false,
                      selectedComment: undefined
                    })
                  }>
                  Close
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    );
  }

  private renderExistingTable(rows: IExistingDisputeRow[]): React.ReactElement<any> {
    if (!rows || rows.length === 0) {
      return <div>No previous transactions found.</div>;
    }

    return (
      <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 12 }}>
        <thead>
          <tr>
            <th style={th}>ID</th>
            <th style={th}>Status</th>
            <th style={th}>Card</th>
            <th style={th}>Date</th>
            <th style={th}>Time</th>
            <th style={th}>Amount</th>
            <th style={th}>Merchant</th>
            <th style={th}>Reason</th>
            <th style={th}>Comment</th>
            <th style={th}>Created</th>
            <th style={th}>Action</th>
          </tr>
        </thead>
        <tbody>
          {rows.map((r) => (
            <tr key={r.id}>
              <td style={td}>{r.id}</td>
              <td style={td}>{r.status || ""}</td>
              <td style={td}>{r.cardMasked || ""}</td>
              <td style={td}>{this.formatDate(r.txnDate) || ""}</td>
              <td style={td}>{this.formatTime(r.txnTime) || ""}</td>
              <td style={td}>{r.txnAmount !== undefined ? r.txnAmount : ""}</td>
              <td style={td}>{r.merchantName || ""}</td>
              <td style={td}>{this.getDisputeReasonText(r.disputeReason) || ""}</td>
              <td style={td}>
                {r.comment ? (
                  <a
                    style={{ color: "#0078d4", cursor: "pointer" }}
                    onClick={() => {
                      this.setState({
                        showCommentModal: true,
                        selectedComment: r.comment
                      });
                    }}>
                    View comment
                  </a>
                ) : (
                  <span style={{ color: "#999" }}> - </span>
                )}
              </td>
              <td style={td}>{this.formatDate(r.created) || ""}</td>
              <td style={td}>
                {this.canAgentDoFullRefund(r) ? (
                  <button
                    disabled={r.refundInProgress}
                    style={{
                      padding: "4px 8px",
                      opacity: r.refundInProgress || r.status === "Refund Initiated" ? 0.6 : 1
                    }}
                    onClick={() => this.confirmAndRefund(r)}>
                    {r.refundInProgress ? "Processing..." : "Full Refund"}
                  </button>
                ) : (
                  this.canCardOpsRefund(r) && (
                    <div>
                      <input
                        type="number"
                        min="0.001"
                        step="0.001"
                        max={r.txnAmount}
                        placeholder="Refund Amount"
                        value={(r as any).refundAmount || ""}
                        onChange={(e) => {
                          const val = (e.target as HTMLInputElement).value;
                          this.setState((prev) => ({
                            currentCaseRows: prev.currentCaseRows.map((x) => (x.id === r.id ? { ...x, refundAmount: val } : x))
                          }));
                        }}
                        style={{
                          width: 90,
                          marginRight: 6
                        }}
                      />
                      <button
                        disabled={r.refundInProgress || !(r as any).refundAmount || Number((r as any).refundAmount) <= 0 || Number((r as any).refundAmount) > r.txnAmount}
                        onClick={() => this.sendPayULinkForRow(r, Number((r as any).refundAmount))}>
                        Send PayU Link
                      </button>

                      {/* <div style={{ marginTop: 4 }}>
                        <button disabled={r.refundInProgress || !(r as any).partialAmount} onClick={() => this.confirmPartialRefundByCardOps(r, Number((r as any).partialAmount))}>
                          Partial Refund
                        </button>
                      </div> */}
                    </div>
                  )
                )}
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    );
  }

  private renderTransactionRow(t: IDisputeTransaction, cards: ICustomerCard[]): React.ReactElement<any> {
    const attachmentNeeded = isAttachmentRequired(t.disputeReason);
    const rowError = this.validateOneTransaction(t);

    return (
      <div key={t.localId} style={{ marginTop: 12, border: "1px solid #ddd", padding: 12, borderRadius: 4 }}>
        <div style={{ display: "flex", justifyContent: "space-between", gap: 8 }}>
          <b>Transaction</b>
          <button onClick={() => this.removeTransactionRow(t.localId)} style={{ padding: "4px 10px" }}>
            Remove
          </button>
        </div>

        {rowError && <div style={{ marginTop: 6, color: "#b00020" }}>{rowError}</div>}

        <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 10, marginTop: 10 }}>
          <div>
            <div>
              <b>Card</b>
            </div>
            {/* <pre style={{ fontSize: 11 }}>{JSON.stringify(cards, null, 2)}</pre> */}
            <select
              value={t.cardNo || ""}
              onChange={(e) => this.updateTransaction(t.localId, { cardNo: (e.target as HTMLSelectElement).value })}
              style={{ padding: 8, width: "100%" }}>
              <option value="">-- Select card --</option>
              {cards.map((c) => (
                <option key={c.cardNo} value={c.cardNo}>
                  {c.maskedCardNo || c.cardNo}
                </option>
              ))}
            </select>
          </div>

          <div>
            <div>
              <b>Dispute Reason</b>
            </div>
            <select
              value={t.disputeReason || ""}
              onChange={(e) => this.updateTransaction(t.localId, { disputeReason: (e.target as HTMLSelectElement).value })}
              style={{ padding: 8, width: "100%" }}>
              {DISPUTE_REASONS.map((r) => (
                <option key={r.key} value={r.key}>
                  {r.text}
                </option>
              ))}
            </select>
            {attachmentNeeded && (
              <div style={{ fontSize: 12, marginTop: 4 }}>
                <b>Attachment is required</b> for this reason.
              </div>
            )}
          </div>

          <div>
            <div>
              <b>Transaction Date</b>
            </div>
            <input
              type="date"
              value={t.txnDate || ""}
              onChange={(e) => this.updateTransaction(t.localId, { txnDate: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "96%" }}
            />
          </div>

          <div>
            <div>
              <b>Transaction Time</b>
            </div>
            <input
              type="time"
              value={t.txnTime || ""}
              onChange={(e) => this.updateTransaction(t.localId, { txnTime: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "96%" }}
            />
          </div>

          <div>
            <div>
              <b>Transaction Amount</b>
            </div>
            <input
              type="text"
              value={t.txnAmount || ""}
              onChange={(e) => {
                const v = (e.target as HTMLInputElement).value;
                if (/^\d*\.?\d*$/.test(v)) {
                  this.updateTransaction(t.localId, { txnAmount: v });
                }
              }}
              placeholder="e.g. 12.500"
              style={{ padding: 8, width: "96%", border: "1px inset #767676", backgroundColor: "field", backgroundImage: "initial" }}
            />
          </div>

          <div>
            <div>
              <b>Merchant Name</b>
            </div>
            <input
              type="text"
              value={t.merchantName || ""}
              onChange={(e) => this.updateTransaction(t.localId, { merchantName: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "96%", border: "1px inset #767676", backgroundColor: "field", backgroundImage: "initial" }}
            />
          </div>

          <div style={{ gridColumn: "1 / span 2" }}>
            <div>
              <b>Comment</b>
            </div>
            <textarea
              value={t.comment || ""}
              onChange={(e) => this.updateTransaction(t.localId, { comment: (e.target as HTMLTextAreaElement).value })}
              style={{ padding: 8, width: "98%", minHeight: 70 }}
            />
          </div>

          <div style={{ gridColumn: "1 / span 2" }}>
            <div>
              <b>Attachment {attachmentNeeded ? "(Required)" : "(Optional)"}</b>
            </div>
            <input
              type="file"
              onChange={(e) => {
                const files = (e.target as HTMLInputElement).files;
                this.updateTransaction(t.localId, { attachment: files && files.length > 0 ? files[0] : null });
              }}
            />
            {t.attachment && <div style={{ fontSize: 12, marginTop: 4 }}>{t.attachment.name}</div>}
          </div>
        </div>
      </div>
    );
  }

  private clearTimers(): void {
    if (this.pollTimer !== undefined) {
      window.clearInterval(this.pollTimer);
      this.pollTimer = undefined;
    }
    if (this.countdownTimer !== undefined) {
      window.clearInterval(this.countdownTimer);
      this.countdownTimer = undefined;
    }
  }

  private onCustomerFound = async (result: ICustomerLookupResult): Promise<void> => {
    this.clearTimers();
    this.setState({
      customer: result.customer,
      cards: result.cards,
      status: "customerFound",
      message: undefined,
      requestId: undefined,
      secondsLeft: 300,
      resultCode: undefined,
      resultDescription: undefined,
      transactions: [],
      loadingExisting: true,
      previousCaseRows: [],
      isNewCase: false
    });

    // load existing disputes for civilId
    try {
      const rows = await this.spSvc.getExistingByCivilId(result.customer.civilId);
      this.setState({ previousCaseRows: rows, loadingExisting: false });
    } catch (e) {
      this.setState({
        previousCaseRows: [],
        loadingExisting: false,
        message: "Failed to load previous transactions: " + (e && (e as any).message ? (e as any).message : "")
      });
    }
  };

  private onCustomerNotFound = (msg: string) => {
    this.clearTimers();
    this.setState({
      customer: undefined,
      cards: undefined,
      status: "idle",
      message: msg,
      requestId: undefined,
      secondsLeft: 300,
      resultCode: undefined,
      resultDescription: undefined,
      transactions: [],
      previousCaseRows: [],
      loadingExisting: false
    });
  };

  private async startPaciAuth(): Promise<void> {
    const customer: ICustomerInfo = this.state.customer;
    if (!customer || !customer.civilId) {
      this.setState({ status: "failed", message: "Please lookup valid Civil ID first." });
      return;
    }

    // MOCK MODE (temporary)
    if (this.state.mockPaci) {
      this.clearTimers();

      const fakeRequestId = "MOCK - " + new Date().getTime();

      this.setState({
        status: "approved",
        requestId: fakeRequestId,
        currentCaseId: this.state.currentCaseId || this.generateCaseId(),
        isNewCase: true,
        resultCode: 10,
        resultDescription: "Authenticated (Mock)",
        message: "PACI Approved (Mock mode)",
        secondsLeft: 300
      });

      return;
    }

    // REAL PACI
    this.clearTimers();
    this.setState({ status: "starting", message: "Sending PACI authentication request...", secondsLeft: 300 });
    try {
      const url: string = this.props.apiBaseUrl.replace(/\/$/, "") + "/api/paci/initiate-auth";

      const resp = await apiPost<{ requestId: string }>(url, {
        authenticationReasonAr: "الحصول على تفويض العميل لتحديث بيانات البطاقة المدنية",
        authenticationReasonEn: "Get Customer Approval to update Civil Details",
        civilNo: customer.civilId,
        assuranceLevel: "Medium",
        serviceDescriptionEN: "Refund claim for a Gift Card",
        serviceDescriptionAR: "طلب استرداد مبلغ لبطاقة الهدايا",
        additionalData: "",
        challenge: ""
      });

      if (!resp || !resp.requestId) {
        this.setState({ status: "failed", message: "No RequestId returned from PACI initiate API." });
        return;
      }

      this.setState({ status: "waiting", requestId: resp.requestId, message: "Waiting for customer approval..." });

      this.startCountdown(resp.requestId);
      this.startPolling(resp.requestId);
    } catch (e) {
      this.setState({ status: "failed", message: e && (e as any).message ? (e as any).message : "Failed to initiate PACI auth." });
    }
  }

  private startCountdown(requestId: string) {
    this.countdownTimer = window.setInterval(() => {
      this.setState((prev) => {
        const next = prev.secondsLeft - 1;
        if (next <= 0) {
          this.clearTimers();
          return { ...prev, secondsLeft: 0, status: "timeout", message: "Timed out (5 minutes). No response received." };
        }
        return { ...prev, secondsLeft: next };
      });
    }, 1000);
  }

  private startPolling(requestId: string) {
    this.pollTimer = window.setInterval(async () => {
      try {
        const url = this.props.apiBaseUrl.replace(/\/$/, "") + "/api/paci/status/" + encodeURIComponent(requestId);

        const s = await apiGet<{
          requestId: string;
          isProcessed: boolean;
          resultCode?: number;
          resultDescription?: string;
        }>(url);

        if (!s || !s.isProcessed) {
          return;
        }

        this.clearTimers();

        const rc: number = s.resultCode;
        const desc: string = s.resultDescription;

        if (rc === 10) {
          this.setState({
            status: "approved",
            currentCaseId: this.state.currentCaseId || this.generateCaseId(),
            resultCode: rc,
            resultDescription: desc,
            message: desc || "Authenticated"
          });
        } else if (rc === 40) {
          this.setState({ status: "rejected", resultCode: rc, resultDescription: desc, message: desc || "Declined" });
        } else {
          this.setState({ status: "failed", resultCode: rc, resultDescription: desc, message: desc || "Failed" });
        }
      } catch (err) {
        // keep polling quietly
      }
    }, 3000);
  }

  private addTransactionRow = (): void => {
    if (this.state.isCaseLocked) {
      return;
    }

    const id = "t_" + new Date().getTime() + "_" + Math.floor(Math.random() * 1000);

    const next: IDisputeTransaction = { localId: id, attachment: null };
    this.setState((prev) => ({
      transactions: prev.transactions.concat([next])
    }));
  };

  private removeTransactionRow = (localId: string): void => {
    if (this.state.isCaseLocked) {
      return;
    }
    this.setState((prev) => ({
      transactions: prev.transactions.filter((x) => x.localId !== localId)
    }));
  };

  private updateTransaction = (localId: string, patch: Partial<IDisputeTransaction>): void => {
    if (this.state.isCaseLocked) {
      return;
    }
    this.setState((prev) => ({
      transactions: prev.transactions.map((x) => (x.localId === localId ? { ...x, ...patch } : x))
    }));
  };

  private validateOneTransaction(t: IDisputeTransaction): string | null {
    if (!t.cardNo) {
      return "Card is required.";
    }
    if (!t.txnDate) {
      return "Transaction date is required.";
    }
    if (!t.txnTime) {
      return "Transaction time is required.";
    }
    if (!t.txnAmount || isNaN(Number(t.txnAmount))) {
      return "Valid amount is required.";
    }
    if (!t.merchantName) {
      return "Merchant name is required.";
    }
    if (!t.disputeReason) {
      return "Dispute reason is required.";
    }

    if (isAttachmentRequired(t.disputeReason) && !t.attachment) {
      return "Attachment is required for selected dispute reason.";
    }

    return null;
  }

  private validateAll(): string | null {
    if (this.state.status !== "approved") {
      return "PACI must be approved before submitting.";
    }
    if (!this.state.customer) {
      return "Customer is missing.";
    }
    if (!this.state.requestId) {
      return "PACI RequestId is missing.";
    }
    if (!this.state.transactions || this.state.transactions.length === 0) {
      return "Please add at least one transaction.";
    }

    for (let i = 0; i < this.state.transactions.length; i++) {
      const err = this.validateOneTransaction(this.state.transactions[i]);
      if (err) {
        return "Row " + (i + 1) + ": " + err;
      }
    }

    return null;
  }

  private submitToSharePoint = async (): Promise<void> => {
    const err = this.validateAll();
    if (err) {
      this.setState({ message: err });
      return;
    }

    if (!this.state.currentCaseId) {
      throw new Error("CaseId is missing. Cannot submit case.");
    }

    const customer = this.state.customer!;
    const paciRequestId = this.state.requestId!;
    const cards = this.state.cards || [];
    const caseId = this.state.currentCaseId;
    const transactions = [...this.state.transactions];

    this.setState({ submitting: true, message: "Submitting case..." });

    try {
      let caseItemId = this.state.caseItemId;

      if (!caseItemId) {
        caseItemId = await this.caseSvc.createCase({
          caseId: caseId,
          civilId: customer.civilId,
          customerName: customer.fullNameEn,
          mobileNumber: customer.mobile
        });

        const encoded = encodeString(caseItemId.toString());
        const deepLink = `${this.props.siteUrl}/SitePages/Floward.aspx?c=${encoded}`;

        await this.caseSvc.updateCaseDeepLink(caseItemId, encoded, deepLink);
        this.setState({ caseItemId: caseItemId, message: "Case created. Uploading transactions..." });
      }

      const submitted: IExistingDisputeRow[] = [];

      await Promise.all(
        transactions.map(async (t) => {
          let masked = "";
          let cardExId = "";

          for (let c = 0; c < cards.length; c++) {
            if (cards[c].cardNo === t.cardNo) {
              masked = cards[c].maskedCardNo;
              cardExId = cards[c].cardExid;
              break;
            }
          }

          const itemId = await this.spSvc.addDisputeItem({
            civilId: customer.civilId,
            caseId: caseId,
            paciRequestId: paciRequestId,
            cardNo: t.cardNo!,
            maskedCardNo: masked,
            cardExId: cardExId,
            txnDate: t.txnDate!,
            txnTime: t.txnTime!,
            txnAmount: Number(t.txnAmount),
            merchantName: t.merchantName!,
            disputeReason: t.disputeReason!,
            comment: t.comment || ""
          });

          if (t.attachment) {
            await this.spSvc.addAttachment(itemId, t.attachment);
          }

          submitted.push({
            id: itemId,
            caseId: caseId,
            civilId: customer.civilId,
            status: "New",
            cardMasked: masked,
            cardExId: cardExId,
            txnDate: t.txnDate!,
            txnTime: t.txnTime!,
            txnAmount: Number(t.txnAmount),
            merchantName: t.merchantName!,
            disputeReason: t.disputeReason!,
            comment: t.comment || "",
            created: new Date().toISOString()
          });
        })
      );

      // refresh existing table
      // const allRows = await this.spSvc.getExistingByCivilId(customer.civilId);
      // const currentCaseRows = allRows.filter((r) => r.caseId === this.state.currentCaseId);
      // const previousRows = allRows.filter((r) => r.caseId !== this.state.currentCaseId);

      this.setState({
        submitting: false,
        message: "Transaction(s) added successfully.",
        transactions: [],
        currentCaseRows: [...(this.state.currentCaseRows || []), ...submitted],
        isNewCase: true,
        status: "approved",
        caseItemId: caseItemId
      });
    } catch (e) {
      this.setState({
        submitting: false,
        message: "Submit failed: " + (e && (e as any).message ? (e as any).message : e ? e.toString() : "")
      });
    }
  };

  private formatDate = (dateStr?: string): string => {
    if (!dateStr) {
      return "";
    }
    const d = new Date(dateStr);
    return d.toLocaleString("en-GB", {
      day: "2-digit",
      month: "short",
      year: "numeric"
    });
  };

  private formatTime = (timeStr?: string): string => {
    if (!timeStr) {
      return "";
    }

    const [h, m] = timeStr.split(":").map(Number);
    const d = new Date();
    d.setHours(h, m, 0, 0);
    return d.toLocaleTimeString("en-US", {
      hour: "2-digit",
      minute: "2-digit",
      hour12: true
    });
  };

  private getDisputeReasonText = (key?: string): string => {
    if (!key) {
      return "";
    }

    for (let i = 0; i < DISPUTE_REASONS.length; i++) {
      if (DISPUTE_REASONS[i].key === key) {
        return DISPUTE_REASONS[i].text;
      }
    }

    return key;
  };

  private generateCaseId(): string {
    return `FLW-${new Date().getFullYear()}-${Date.now()}`;
  }

  private callFullRefundApi = async (cardExid: string): Promise<void> => {
    const login = this.props.context.pageContext.user.loginName;
    const userId = getCleanUserId(login);

    const url = `${this.props.apiBaseUrl.replace(/\/$/, "")}/api/floward/refund/full`;

    await apiPost(url, {
      cardExid: cardExid,
      userId: userId
    });
  };

  private confirmAndRefund = async (row: IExistingDisputeRow): Promise<void> => {
    const ok = window.confirm(`Are you sure you want to initiate full refund and block this card?\n\n${row.cardMasked}`);

    if (!ok) {
      return;
    }

    this.setState({ payuInProgress: true, message: "Generating PayU link and blocking card..." });

    this.setState((prev) => ({
      currentCaseRows: prev.currentCaseRows.map((r) => (r.id === row.id ? { ...r, refundInProgress: true } : r))
    }));
    try {
      await this.callFullRefundApi(row.cardExId);

      await this.spSvc.updateTransactionStatus(row.id, TransactionStatus.RefundInitiated, "PayU link generated and card blocked");

      await this.caseSvc.updateCaseStatus(this.state.caseItemId!, "Pending With Card Operation", "PayU link sent to customer");

      this.setState((prev) => ({
        currentCaseRows: prev.currentCaseRows.map((r) => (r.id === row.id ? { ...r, status: TransactionStatus.RefundInitiated, refundInProgress: false } : r)),
        payuInProgress: false,
        caseStatus: "Pending With Card Operation",
        message: "Avaialble card balance will be refund and the card will be stopped."
      }));

      alert("Full refund request sent successfully.");
    } catch (e) {
      this.setState((prev) => ({
        currentCaseRows: prev.currentCaseRows.map((r) => (r.id === row.id ? { ...r, refundInProgress: false } : r)),
        payuInProgress: false,
        message: "Failed to generate PayU link. Please retry."
      }));
    }
  };

  private submitCaseForWorkflow = async (): Promise<void> => {
    const ok = window.confirm("Once submitted, this case will be sent to Card Operation and cannot be edited.\n\nDo you want to continue?");

    if (!ok) {
      return;
    }

    try {
      const caseItemId = this.state.caseItemId!;
      // const caseId = this.state.currentCaseId!;

      await this.caseSvc.updateCaseStatus(caseItemId, "Submitted", "Case submitted by agent");

      await this.caseSvc.updateCaseStatus(caseItemId, "Pending With Card Operation", "Pending With Card Operation queue");

      await this.nintexSvc.logActionHistory({
        caseItemId: caseItemId,
        action: "Submit Case",
        comment: "Case submitted and routed to Card Operation",
        taskId: null,
        taskName: ""
      });

      this.setState({
        isCaseLocked: true,
        caseStatus: "Pending With Card Operation",
        message: "Case submitted successfully and sent to Card Operation."
      });

      alert("Case submitted successfully.");
    } catch (e) {
      alert("Failed to submit case.");
    }
  };

  private isCaseOverriddenByNintex(): boolean {
    const status = this.state.caseStatus;

    return status === "Pending With Card Operation" || status === "Hold By Card Operation" || status === "Pending With Outbound" || status === "Rejected By Card Operation";
  }

  // private confirmFullRefundByCardOps = async (row: IExistingDisputeRow): Promise<void> => {
  //   const ok = window.confirm(`Confirm FULL refund for card ${row.cardMasked}?`);
  //   if (!ok) return;

  //   this.setState((prev) => ({
  //     currentCaseRows: prev.currentCaseRows.map((r) => (r.id === row.id ? { ...r, refundInProgress: true } : r))
  //   }));

  //   try {
  //     await this.callFullRefundApi(row.cardExId);

  //     await this.processRefund(row, TransactionStatus.FullRefundCompleted as TransactionStatus, "Full refund approved by Card Operation");
  //   } catch (e) {
  //     alert("Full refund API failed");

  //     this.setState((prev) => ({
  //       currentCaseRows: prev.currentCaseRows.map((r) => (r.id === row.id ? { ...r, refundInProgress: false } : r))
  //     }));
  //   }
  // };

  // private confirmPartialRefundByCardOps = async (row: IExistingDisputeRow, amount: number): Promise<void> => {
  //   if (!amount || amount < 0 || amount >= row.txnAmount) {
  //     alert("Enter a valid partial refund amount.");
  //     return;
  //   }

  //   const ok = window.confirm(`Confirm PARTIAL refund for card ${row.cardMasked}?`);
  //   if (!ok) {
  //     return;
  //   }

  //   await this.processRefund(row, TransactionStatus.PartialRefundCompleted as TransactionStatus, `Partial refund of ${amount} approved by Card Operation`, amount);
  // };

  private sendPayULinkForRow = async (row: IExistingDisputeRow, amount: number): Promise<void> => {
    if (!amount || amount <= 0 || amount > row.txnAmount) {
      alert("Invalid refund amount.");
      return;
    }

    const ok = window.confirm(`Send PayU link for ${amount} on card ${row.cardMasked}?`);
    if (!ok) return;

    this.setState((prev) => ({
      currentCaseRows: prev.currentCaseRows.map((r) => (r.id === row.id ? { ...r, refundInProgress: true } : r))
    }));

    try {
      // SAME PayU API
      await this.callPayURefundApi(row.cardExId, amount);

      const status = amount === row.txnAmount ? TransactionStatus.FullRefundCompleted : TransactionStatus.PartialRefundCompleted;

      const comment = amount === row.txnAmount ? "Full refund by Cards Ops" : `Partial refund (${amount}) by Cards Ops`;

      await this.spSvc.updateTransactionStatus(row.id, status, comment, amount);

      const rows = await this.spSvc.getByCaseId(this.state.currentCaseId!);
      const caseStatus = calculateCaseStatusFromTransactions(rows);

      await this.caseSvc.updateCaseStatus(this.state.caseItemId!, caseStatus, "Refund processed by Cards Ops");

      this.setState({
        currentCaseRows: rows,
        caseStatus
      });
    } catch (e) {
      alert("Failed to send PayU link.");
      this.setState((prev) => ({
        currentCaseRows: prev.currentCaseRows.map((r) => (r.id === row.id ? { ...r, refundInProgress: false } : r))
      }));
    }
  };

  // private processRefund = async (row: IExistingDisputeRow, newStatus: TransactionStatus, comment: string, partialAmount?: number): Promise<void> => {
  //   this.setState((prev) => ({
  //     currentCaseRows: prev.currentCaseRows.map((r) => (r.id === row.id ? { ...r, refundInProgress: true } : r))
  //   }));

  //   try {
  //     await this.spSvc.updateTransactionStatus(row.id, newStatus, comment, partialAmount);

  //     const rows = await this.spSvc.getByCaseId(this.state.currentCaseId!);

  //     const caseStatus = calculateCaseStatusFromTransactions(rows);

  //     await this.caseSvc.updateCaseStatus(this.state.caseItemId!, caseStatus, "Transaction refund update");

  //     this.setState({
  //       currentCaseRows: rows
  //     });
  //   } catch (e) {
  //     alert("Refund processing failed.");
  //     this.setState((prev) => ({
  //       currentCaseRows: prev.currentCaseRows.map((r) => (r.id === row.id ? { ...r, refundInProgress: false } : r))
  //     }));
  //   }
  // };

  private canAgentDoFullRefund(row: IExistingDisputeRow): boolean {
    return (
      row.disputeReason === "FRAUD" &&
      !!row.cardExId &&
      !this.state.isCaseLocked &&
      row.status !== TransactionStatus.RefundInitiated &&
      row.status !== TransactionStatus.FullRefundCompleted
    );
  }

  private canCardOpsRefund(row: IExistingDisputeRow): boolean {
    return (
      row.disputeReason === "FRAUD" &&
      !!row.cardExId &&
      this.state.view === "openCase" &&
      row.status !== TransactionStatus.FullRefundCompleted &&
      row.status !== TransactionStatus.PartialRefundCompleted
    );
  }

  private getCaseBadgeText(): string {
    const s = this.state.caseStatus;

    if (!s || s === "Draft" || s === "New") return "Draft";
    if (s === "Submitted") return "Submitted";
    if (s === "Pending With Card Operation" || s === "Hold By Card Operation" || s === "Pending With Outbound") return "In Progress";

    return s;
  }

  private getCaseBadgeColor(): string {
    const text = this.getCaseBadgeText();

    switch (text) {
      case "Draft":
        return "#757575";
      case "Submitted":
        return "#1976d2";
      case "In Progress":
        return "#f57c00";
      case "Rejected":
        return "#d32f2f";
      case "Closed":
        return "#388e3c";
      default:
        return "#455a64";
    }
  }

  private callPayURefundApi = async (cardExid: string, refundAmount: number): Promise<void> => {
    const userId = getCleanUserId(this.props.context.pageContext.user.loginName);

    // Change this api Once you get correct once
    await apiPost(`${this.props.apiBaseUrl.replace(/\/$/, "")}/api/floward/refund`, {
      cardExid,
      userId,
      refundAmount
    });
  };
}
const th: React.CSSProperties = { borderBottom: "1px solid #ddd", textAlign: "left", padding: 6 };
const td: React.CSSProperties = { borderBottom: "1px solid #f0f0f0", padding: 6, verticalAlign: "top" };
