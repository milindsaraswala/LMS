import * as React from 'react';
import { Course, Lesson, Module } from '../common/models';
import { getSP } from '../common/pnp';
import { dedupeConcat, mergeObjects } from '../common/utils';

type Props = { context: any; courseId?: number; courseCode?: string; preview?: boolean };
type QuizState = {
	answers: { [qid: string]: string[] };
	submitted: boolean;
	score?: { points: number; max: number; percent: number; passed: boolean };
};
type ProgressModel = {
	completed: number[];
	bookmarkLessonId?: number;
	videoPos?: { [lessonId: number]: number };
	quiz?: { [lessonId: number]: { points: number; max: number; percent: number; passed: boolean } };
};
type Enrollment = { id: number; progress: ProgressModel };
type State = {
	loading: boolean;
	course?: Course;
	modules: Module[];
	lessonsByModule: { [k: number]: Lesson[] };
	activeModuleId?: number;
	activeLessonId?: number;
	error?: string;

	quizByLesson: { [lessonId: number]: QuizState };
	enrollment?: Enrollment;
};

export default class CoursePlayer extends React.Component<Props, State> {
	constructor(props: Props) {
		super(props);
		this.state = { loading: true, modules: [], lessonsByModule: {}, quizByLesson: {} };
	}

	public componentDidMount() {
		this.load();
	}

	public render() {
		if (this.state.loading) return <div>Loading…</div>;
		if (this.state.error) return <div style={{ color: 'red' }}>Error: {this.state.error}</div>;

		const { modules, lessonsByModule, activeModuleId, activeLessonId } = this.state;
		const active = activeModuleId && activeLessonId ? (lessonsByModule[activeModuleId] || []).filter((x) => x.Id === activeLessonId)[0] : null;

		return (
			<div style={{ display: 'flex', gap: 16 }}>
				{/* Sidebar */}
				<div style={{ width: 320, minWidth: 280, maxHeight: '70vh', overflow: 'auto', borderRight: '1px solid #eee', paddingRight: 8 }}>
					{modules.map((m) => {
						const unlocked = this.isModuleUnlocked(m);
						return (
							<div key={m.Id} style={{ marginBottom: 12, opacity: unlocked ? 1 : 0.5 }}>
								<div style={{ fontWeight: 700, marginBottom: 6 }}>
									{m.Title} {!unlocked ? <span style={{ fontSize: 12, color: '#a00' }}>(Locked)</span> : null}
								</div>
								<ul style={{ listStyle: 'none', paddingLeft: 0, margin: 0 }}>
									{(lessonsByModule[m.Id] || []).map((l) => {
										const _active = this.state.activeModuleId === m.Id && this.state.activeLessonId === l.Id;
										const completed = this.isLessonCompleted(l.Id);

										const modUnlocked = this.isModuleUnlocked(m);
										const lessonUnlocked = this.isLessonUnlockedInModule(m.Id, l.Id);
										const disabled = !(modUnlocked && lessonUnlocked);

										return (
											<li key={l.Id}>
												<a
													href='#'
													onClick={(e) => {
														e.preventDefault();
														if (disabled) return;
														this.setState({ activeModuleId: m.Id, activeLessonId: l.Id });
														this.saveProgress({ bookmarkLessonId: l.Id }); // keep resume updated as user navigates
													}}
													style={{
														display: 'flex',
														gap: 6,
														alignItems: 'center',
														padding: '6px 8px',
														borderRadius: 4,
														textDecoration: 'none',
														color: disabled ? '#888' : _active ? '#fff' : '#222',
														background: _active ? '#0078d4' : 'transparent',
														pointerEvents: disabled ? 'none' : 'auto'
													}}
													title={disabled ? 'Complete previous modules to unlock' : l.Title}>
													<span style={{ width: 14 }}>{completed ? '✓' : ''}</span>
													<span style={{ flex: 1, minWidth: 0, whiteSpace: 'normal' }}>
														{(l.Order0 || 0) + '. '}
														{l.Title}
													</span>
												</a>
											</li>
										);
									})}
								</ul>
							</div>
						);
					})}
				</div>

				{/* Player */}
				<div style={{ flex: 1, minWidth: 0 }}>
					{active ? (
						<div>
							{/* sticky header */}
							<div style={{ position: 'sticky', top: 0, background: '#fff', zIndex: 2, padding: '6px 0', borderBottom: '1px solid #eee', marginBottom: 8 }}>
								<div style={{ fontSize: 18, fontWeight: 700 }}>
									{active.Title} {this.renderLessonActions(active)}
								</div>
								<div style={{ opacity: 0.7, fontSize: 12 }}>
									{(active.ContentTypeChoice || '').toUpperCase()}
									{active.EstimatedMinutes ? ` • ${active.EstimatedMinutes} min` : ''}
								</div>
								{this.renderNavBar()}
							</div>

							{/* content */}
							{this.renderLesson(active)}
						</div>
					) : (
						<div>Select a lesson…</div>
					)}
				</div>
			</div>
		);
	}

	private getCourseIdFromQS(): number | null {
		let s = window.location.search || '';
		if (s.indexOf('?') === 0) s = s.substring(1);
		const parts = s.split('&');
		for (let i = 0; i < parts.length; i++) {
			const kv = parts[i].split('=');
			if (decodeURIComponent(kv[0]) === 'courseId') {
				const v = kv.length > 1 ? decodeURIComponent(kv[1]) : '';
				const n = Number(v);
				return isNaN(n) ? null : n;
			}
		}
		return null;
	}

	private escOData(s: string) {
		// tslint:disable-next-line
		return (s || '').replace(/'/g, "''");
	}

	private async resolveCourseId(sp: any): Promise<number | null> {
		const qs = this.getCourseIdFromQS();
		if (qs && !isNaN(qs)) return qs;

		if (this.props.courseId && this.props.courseId > 0) return Number(this.props.courseId);

		if (this.props.courseCode) {
			const code = this.escOData(this.props.courseCode);
			const found = await sp.web.lists.getByTitle('Courses').items.select('Id', 'Code').filter(`Code eq '${code}'`).top(1)();
			return found.length ? found[0].Id : null;
		}
		return null;
	}

	private async load() {
		const sp = getSP(this.props.context);

		try {
			const resolved = await this.resolveCourseId(sp);
			const id = resolved != null ? Number(resolved) : NaN;
			if (!isFinite(id) || id <= 0) {
				this.setState({ loading: false, error: 'No courseId configured' });
				return;
			}

			// Course
			const courseItem = await sp.web.lists.getByTitle('Courses').items.select('Id', 'Title', 'Description', 'ThumbnailUrl').filter(`Id eq ${id}`).top(1)();
			if (!courseItem.length) {
				this.setState({ loading: false, error: 'Course not found' });
				return;
			}
			const course = courseItem[0];
			this.setState({
				course: { Id: course.Id, Title: course.Title, Description: course.Description, ThumbnailUrl: course.ThumbnailUrl }
			});

			const modsRaw = await sp.web.lists
				.getByTitle('Modules')
				.items.select('Id', 'Title', 'Order0', 'CourseId')
				.filter(`CourseId eq ${id}`)
				.orderBy('Order0', true)
				.orderBy('Id', true)
				.top(5000)();

			const modules: Module[] = modsRaw.map((m: any) => ({
				Id: m.Id,
				Title: m.Title,
				Order0: m.Order0,
				CourseId: id
			}));
			this.setState({ modules });

			const lessonsBy: { [k: number]: Lesson[] } = {};
			if (modules.length) {
				const ids: number[] = modules.map((m) => m.Id);

				const lessonsRaw = await sp.web.lists
					.getByTitle('Lessons')
					.items.select('Id', 'Title', 'Order0', 'ContentTypeChoice', 'ContentUrl', 'HtmlContent', 'QuizJson', 'EstimatedMinutes', 'Module/Id', 'Module/Title')
					.expand('Module')
					.orderBy('ModuleId', true)
					.orderBy('Order0', true)
					.orderBy('Id', true)
					.top(5000)();

				(lessonsRaw || []).forEach((l: Lesson) => {
					const modId = l.Module ? l.Module.Id : l.ModuleId;

					if (ids.indexOf(modId) === -1) return;

					const contentUrl = this.getUrlString(l.ContentUrl);

					(lessonsBy[modId] = lessonsBy[modId] || []).push({
						Id: l.Id,
						Title: l.Title,
						Order0: l.Order0,
						ContentTypeChoice: l.ContentTypeChoice,
						ContentUrl: contentUrl,
						HtmlContent: l.HtmlContent,
						QuizJson: l.QuizJson,
						EstimatedMinutes: l.EstimatedMinutes,
						ModuleId: modId
					} as Lesson);
				});
			}

			const enrollment = await this.getOrCreateEnrollment(sp, id);

			const moduleIds = modules.map((m) => m.Id);
			const byMod = lessonsBy;

			let startModId = modules.length ? modules[0].Id : undefined;
			let startLessonId: number | undefined = undefined;

			const bookmark = enrollment.progress.bookmarkLessonId;
			if (bookmark) {
				for (let i = 0; i < moduleIds.length; i++) {
					const mid = moduleIds[i];
					const list = byMod[mid] || [];
					let j,
						hit = null;
					for (j = 0; j < list.length; j++) {
						if (list[j].Id === bookmark) {
							hit = list[j];
							break;
						}
					}
					if (hit) {
						startModId = mid;
						startLessonId = hit.Id;
						break;
					}
				}
			}

			if (!startLessonId) {
				outer: for (const mid of moduleIds) {
					for (const l of byMod[mid] || []) {
						if (!this.isLessonCompleted(l.Id)) {
							startModId = mid;
							startLessonId = l.Id;
							break outer;
						}
					}
				}
			}

			if (!startLessonId && startModId) {
				const list = byMod[startModId] || [];
				startLessonId = list.length ? list[0].Id : undefined;
			}

			this.setState({
				lessonsByModule: lessonsBy,
				activeModuleId: startModId,
				activeLessonId: startLessonId,
				loading: false,
				enrollment
			});
			this.tryMarkCourseCompleted(this.state.enrollment ? this.state.enrollment.progress : { completed: [] });
		} catch (e) {
			this.setState({ loading: false, error: e && (e as any).message ? (e as any).message : String(e) });
		}
	}

	private renderLesson(l: Lesson) {
		const kind = (l.ContentTypeChoice || '').toUpperCase();
		const url = (l.ContentUrl || '').trim();
		const ext = this.ext(url);

		// HTML
		if (kind === 'HTML') return <div style={{ border: '1px solid #eee', padding: 10 }} dangerouslySetInnerHTML={{ __html: l.HtmlContent || '' }} />;

		// PDF
		if (kind === 'PDF' || ext === '.pdf') {
			const raw = (l.ContentUrl || '').trim();
			if (!raw) return <div style={{ color: '#a00' }}>No PDF URL configured.</div>;

			// If file is in your SharePoint tenant → use WOPI
			/*if (this.isSameOrigin(raw)) {
				const wopi = this.toWopiEmbedUrl(raw);
				const alt = this.toWopiPreviewUrl(raw);
				return (
					<div>
						<iframe
							src={wopi}
							style={{ width: '100%', height: 600, border: 0 }}
							onError={(e) => {
								const f = e.currentTarget as HTMLIFrameElement;
								if (f && f.src !== alt) f.src = alt;
							}}
						/>
						<div style={{ marginTop: 6 }}>
							<a href={this.ensureAbsoluteUrl(raw)} target='_blank' rel='noreferrer'>
								Open PDF
							</a>
						</div>
					</div>
				);
			}*/

			// External PDFs (not same origin):
			// Try native browser PDF viewer; if blocked by CSP/X-Frame-Options, the link still works.
			const abs = this.ensureAbsoluteUrl(raw);
			return (
				<div>
					<object data={abs} type='application/pdf' style={{ width: '100%', height: 600 }}>
						<embed src={abs} type='application/pdf' />
					</object>
					<div style={{ marginTop: 6 }}>
						<a href={abs} target='_blank' rel='noreferrer'>
							Open PDF
						</a>
					</div>
				</div>
			);
		}

		// PPT/DOC/XLS via WOPI
		if (kind === 'PPT' || kind === 'DOC' || kind === 'XLS' || ext === '.ppt' || ext === '.pptx' || ext === '.doc' || ext === '.docx' || ext === '.xls' || ext === '.xlsx') {
			if (!url) return <div style={{ color: '#a00' }}>No file URL configured.</div>;
			const wopi = this.toWopiEmbedUrl(url);
			return (
				<div>
					<iframe src={wopi} style={{ width: '100%', height: 600, border: 0 }} />
					<div style={{ marginTop: 6 }}>
						<a href={this.ensureAbsoluteUrl(url)} target='_blank'>
							Open file
						</a>
					</div>
				</div>
			);
		}

		// LINK (generic)
		if (kind === 'LINK') {
			if (!url) return <div style={{ color: '#a00' }}>No link set.</div>;
			return (
				<a href={this.ensureAbsoluteUrl(url)} target='_blank'>
					{url}
				</a>
			);
		}

		// VIDEO
		if (kind === 'VIDEO') {
			if (!url) return <div style={{ color: '#a00' }}>No video URL.</div>;
			return (
				<video
					src={this.ensureAbsoluteUrl(url)}
					controls
					style={{ width: '100%' }}
					onTimeUpdate={(e) => {
						const t = (e.currentTarget as HTMLVideoElement).currentTime;
						const lessonId = l.Id;
						const cur = this.getVideoPosMap();
						// Throttle saves or save locally; here just local state to avoid spamming the list:
						this.setState((s) => ({
							enrollment: s.enrollment
								? {
										...s.enrollment,
										progress: { ...s.enrollment.progress, videoPos: { ...cur, [lessonId]: t } }
								  }
								: s.enrollment
						}));
					}}
					onPause={async (ev) => {
						// const cur = this.state.enrollment && this.state.enrollment.progress && this.state.enrollment.progress.videoPos ? this.state.enrollment.progress.videoPos : {};
						const pos = (ev.currentTarget as HTMLVideoElement).currentTime;
						const patch: any = { videoPos: {} };
						patch.videoPos[l.Id] = pos;
						await this.saveProgress(patch); // persist on pause
					}}
					onLoadedMetadata={(e) => {
						const t = this.getSavedVideoTime(l.Id);
						if (t !== null) {
							(e.currentTarget as HTMLVideoElement).currentTime = t;
						}
					}}
				/>
			);
		}

		// AUDIO
		if (kind === 'AUDIO') {
			if (!url) return <div style={{ color: '#a00' }}>No audio URL.</div>;
			return <audio src={this.ensureAbsoluteUrl(url)} controls />;
		}

		// QUIZ (read-only preview)
		if (kind === 'QUIZ') {
			const model = this.getQuizModel(l);
			if (!model || !Array.isArray(model.questions) || model.questions.length === 0) {
				return <div style={{ color: '#a00' }}>No questions configured.</div>;
			}
			const qState = this.getQuizState(l.Id);
			const submitted = qState.submitted;
			const score = qState.score;

			return (
				<div>
					{model.title ? <div style={{ fontWeight: 700, marginBottom: 8 }}>{model.title}</div> : null}

					{model.questions.map((q: any, qi: number) => {
						const chosenArr: string[] = qState.answers[q.id] || [];
						const single = q.type === 'single' || q.type === 'boolean';
						const correctArr: string[] = q.correctOptionIds || [];

						return (
							<div key={q.id || qi} style={{ border: '1px solid #eee', borderRadius: 6, padding: 10, marginBottom: 10 }}>
								<div style={{ fontWeight: 600, marginBottom: 6 }}>
									Q{qi + 1} ({q.type}) • {q.points || 1} pt
								</div>
								<div style={{ marginBottom: 8 }}>{q.text}</div>

								{(q.options || []).map((o: any) => {
									const checked = chosenArr.indexOf(o.id) !== -1;
									// after submit, show correctness styling
									const showCheck = submitted;
									const isCorrectOption = correctArr.indexOf(o.id) !== -1;
									const isUserChoice = checked;

									let rowStyle: React.CSSProperties = { padding: '4px 6px', borderRadius: 4, display: 'flex', alignItems: 'center', gap: 8 };
									if (showCheck) {
										if (isCorrectOption) rowStyle.background = '#e7f7ee'; // greenish for correct answer
										if (isUserChoice && !isCorrectOption) rowStyle.background = '#fdeaea'; // reddish for wrong chosen
									}

									return (
										<label key={o.id} style={rowStyle}>
											<input
												type={single ? 'radio' : 'checkbox'}
												name={single ? `q_${q.id}` : undefined}
												checked={checked}
												disabled={submitted}
												onChange={(e) => this.toggleAnswer(l.Id, q, o.id, e.currentTarget.checked)}
											/>
											<span>{o.text}</span>
										</label>
									);
								})}
							</div>
						);
					})}

					{!submitted ? (
						<div style={{ marginTop: 8 }}>
							<button onClick={() => this.submitQuiz(l.Id, model)}>Submit</button>
						</div>
					) : (
						<div style={{ marginTop: 8 }}>
							<div style={{ fontWeight: 700 }}>
								Score: {score && score.points}/{score && score.max} ({score && score.percent}%){' '}
								{score && score.passed ? <span style={{ color: '#0a7' }}>• Passed</span> : <span style={{ color: '#c00' }}>• Not passed</span>}
							</div>
							{score && !score.passed ? (
								<div style={{ marginTop: 6 }}>
									<button onClick={() => this.resetQuiz(l.Id)}>Try again</button>
								</div>
							) : null}
						</div>
					)}
				</div>
			);
		}

		return <div>Unsupported content.</div>;
	}

	private getUrlString = (v: any): string => (v && typeof v === 'object' ? v.Url || v.url || '' : v || '');

	private ensureAbsoluteUrl = (u: string) => (!u ? '' : /^https?:\/\//i.test(u) ? u : location.origin + (u.startsWith('/') ? u : '/' + u));

	private cleanFileUrl = (u: string) => {
		if (!u) return '';
		const a = document.createElement('a');
		a.href = this.ensureAbsoluteUrl(u);
		// remove ?web=1 and other viewer flags; keep the base path
		a.search = a.search
			.replace(/([?&])web=1(&|$)/i, '$1') // drop web=1
			.replace(/([?&])download=1(&|$)/i, '$1') // drop download=1
			.replace(/([?&])action=[^&]*/i, '') // drop action=
			.replace(/^[?&]+$/, '');
		return a.pathname ? location.origin + a.pathname : this.ensureAbsoluteUrl(u);
	};

	private toPdfViewerUrl = (u: string) => {
		const abs = this.ensureAbsoluteUrl(u);
		// SharePoint PDF viewer (works with tenant files & server-relative paths)
		return `${location.origin}/_layouts/15/pdfviewer.aspx?file=${encodeURIComponent(abs)}&action=default`;
	};

	private toWopiEmbedUrl = (u: string) => {
		const abs = this.cleanFileUrl(u);
		// WOPI works for PDFs & Office docs if the file is in your tenant
		return `${location.origin}/_layouts/15/WopiFrame.aspx?sourcedoc=${encodeURIComponent(abs)}&action=embedview`;
	};

	private toWopiPreviewUrl = (u: string) => {
		const abs = this.cleanFileUrl(u);
		return `${location.origin}/_layouts/15/WopiFrame.aspx?sourcedoc=${encodeURIComponent(abs)}&action=interactivepreview`;
	};

	private ext = (u: string) => {
		const m = (u || '').toLowerCase().match(/\.[a-z0-9]+(\?|#|$)/);
		return m ? m[0] : '';
	};

	private isSameOrigin = (u: string) => {
		try {
			const { origin } = new URL(this.ensureAbsoluteUrl(u));
			return origin === location.origin;
		} catch {
			return false;
		}
	};

	private renderNavBar = () => {
		const lessonsByModule = this.state.lessonsByModule;
		const activeModuleId = this.state.activeModuleId;
		const activeLessonId = this.state.activeLessonId;
		if (!activeModuleId || !activeLessonId) return null;

		const list = lessonsByModule[activeModuleId] || [];
		let idx = -1;
		for (let i = 0; i < list.length; i++) {
			if (list[i].Id === activeLessonId) {
				idx = i;
				break;
			}
		}
		const prev = idx > 0 ? list[idx - 1] : null;
		const next = idx >= 0 && idx < list.length - 1 ? list[idx + 1] : null;

		const pct = list.length ? Math.round(((idx + 1) / list.length) * 100) : 0;
		const go = (l?: Lesson) => {
			if (l) this.setState({ activeLessonId: l.Id });
		};

		return (
			<div style={{ display: 'flex', alignItems: 'center', gap: 8, marginTop: 6 }}>
				<button
					disabled={!prev}
					onClick={() => {
						go(prev as any);
					}}>
					◀ Prev
				</button>
				<div style={{ flex: 1, height: 6, background: '#eee', borderRadius: 3 }}>
					<div style={{ width: pct + '%', height: 6, background: '#0078d4', borderRadius: 3 }} />
				</div>
				<span style={{ width: 38, textAlign: 'right', fontSize: 12 }}>{pct}%</span>
				<button
					disabled={!next}
					onClick={() => {
						go(next as any);
					}}>
					Next ▶
				</button>
			</div>
		);
	};

	private getQuizModel = (l: Lesson) => {
		try {
			return l.QuizJson ? JSON.parse(l.QuizJson as any) : null;
		} catch {
			return null;
		}
	};

	private getQuizState = (lessonId: number): QuizState => {
		return this.state.quizByLesson[lessonId] || { answers: {}, submitted: false };
	};

	private setQuizState = (lessonId: number, patch: Partial<QuizState>) => {
		this.setState((s) => {
			const next: any = {};
			let k: string;
			for (k in s.quizByLesson) if (Object.prototype.hasOwnProperty.call(s.quizByLesson, k)) next[k] = s.quizByLesson[k];

			const base: QuizState = next[lessonId] || { answers: {}, submitted: false };
			const merged: QuizState = {
				answers: patch.answers ? patch.answers : base.answers,
				submitted: typeof patch.submitted === 'boolean' ? patch.submitted : base.submitted,
				score: typeof patch.score !== 'undefined' ? patch.score : base.score
			};
			next[lessonId] = merged;
			return { quizByLesson: next } as any;
		});
	};

	private toggleAnswer = (lessonId: number, q: any, optId: string, checked: boolean) => {
		const qs = this.getQuizState(lessonId);
		let current = qs.answers[q.id] ? qs.answers[q.id].slice() : [];

		if (q.type === 'single' || q.type === 'boolean') {
			current = checked ? [optId] : [];
		} else {
			const idx = current.indexOf(optId);
			if (checked) {
				if (idx === -1) current.push(optId);
			} else {
				if (idx !== -1) current.splice(idx, 1);
			}
		}

		const nextAnswers: any = {};
		let k: string;
		for (k in qs.answers) if (Object.prototype.hasOwnProperty.call(qs.answers, k)) nextAnswers[k] = qs.answers[k];
		nextAnswers[q.id] = current;

		this.setQuizState(lessonId, { answers: nextAnswers });
	};

	private submitQuiz = async (lessonId: number, qModel: any) => {
		const qs = this.getQuizState(lessonId);
		let points = 0;
		let max = 0;

		(qModel.questions || []).forEach((q: any) => {
			const correct = (q.correctOptionIds || []).slice().sort();
			const chosen = (qs.answers[q.id] || []).slice().sort();
			const qPoints = Number(q.points) > 0 ? Number(q.points) : 1;
			max += qPoints;

			let ok = correct.length === chosen.length;
			if (ok) {
				for (let i = 0; i < correct.length; i++) {
					if (correct[i] !== chosen[i]) {
						ok = false;
						break;
					}
				}
			}
			if (ok) points += qPoints;
		});

		const percent = max ? Math.round((points / max) * 100) : 0;
		const passed = percent >= 70;
		const result = { points: points, max: max, percent: percent, passed: passed };

		// ES5-safe computed key
		const patchQuiz: any = {};
		patchQuiz[lessonId] = result;
		await this.saveProgress({ quiz: patchQuiz });
		this.setQuizState(lessonId, { submitted: true, score: result });

		if (passed) await this.saveProgress({ completed: [lessonId] });
	};

	private resetQuiz = (lessonId: number) => {
		this.setQuizState(lessonId, { answers: {}, submitted: false, score: undefined });
	};

	private async getOrCreateEnrollment(sp: any, courseId: number): Promise<Enrollment> {
		const me = await sp.web.currentUser();
		const uid = me.Id;
		const uLoginName: string = me.LoginName.split('\\')[1];

		const found = await sp.web.lists
			.getByTitle('CourseEnrollment')
			.items.select('Id', 'CourseId', 'UserId', 'ProgressJson')
			.filter(`CourseId eq ${courseId} and UserId eq ${uid}`)
			.top(1)();

		if (found.length) {
			const p: ProgressModel = this.parseProgress(found[0].ProgressJson);
			return { id: found[0].Id, progress: p };
		}

		const blank: ProgressModel = { completed: [] };
		const add = await sp.web.lists.getByTitle('CourseEnrollment').items.add({
			Title: `Course ${courseId} - User (${uLoginName})`,
			CourseId: courseId,
			UserId: uid,
			ProgressJson: JSON.stringify(blank),
			Status: 'InProgress',
			StartedOn: new Date()
		});

		return { id: add.data.Id, progress: blank };
	}

	private parseProgress(json: string | null | undefined): ProgressModel {
		try {
			const p = json ? JSON.parse(json) : null;
			if (p && typeof p === 'object') {
				const completed = [];
				if (p.completed && p.completed.length) {
					for (let i = 0; i < p.completed.length; i++) {
						const n = Number(p.completed[i]);
						if (!isNaN(n)) completed.push(n);
					}
				}
				return {
					completed: completed,
					bookmarkLessonId: p.bookmarkLessonId,
					videoPos: p.videoPos || {},
					quiz: p.quiz || {}
				};
			}
			return { completed: [] };
		} catch {
			return { completed: [] };
		}
	}

	private async saveProgress(patch: Partial<ProgressModel>) {
		if (!this.state.enrollment) return;

		const current = this.state.enrollment.progress;

		const mergedCompleted = dedupeConcat(current.completed, patch.completed);
		const mergedBookmark = typeof patch.bookmarkLessonId === 'number' ? patch.bookmarkLessonId : current.bookmarkLessonId;

		const mergedVideoPos = mergeObjects(current.videoPos, patch.videoPos);
		const mergedQuiz = mergeObjects(current.quiz, patch.quiz);

		const merged: ProgressModel = {
			completed: mergedCompleted,
			bookmarkLessonId: mergedBookmark,
			videoPos: mergedVideoPos,
			quiz: mergedQuiz
		};

		const sp = getSP(this.props.context);
		await sp.web.lists
			.getByTitle('CourseEnrollment')
			.items.getById(this.state.enrollment.id)
			.update({
				ProgressJson: JSON.stringify(merged)
			});
		this.setState({ enrollment: { id: this.state.enrollment.id, progress: merged } as Enrollment }, () => {
			this.tryMarkCourseCompleted(merged);
		});
	}

	// Convenience:
	private isLessonCompleted = (lessonId: number) => {
		const e = this.state.enrollment;
		const p = e ? e.progress : null;
		if (!p || !p.completed) return false;
		return p.completed.indexOf(lessonId) >= 0;
	};

	private renderLessonActions(l: Lesson) {
		const completed = this.isLessonCompleted(l.Id);
		const kind = (l.ContentTypeChoice || '').toUpperCase();

		const lessonUnlocked = this.isLessonUnlockedInModule(l.ModuleId, l.Id);

		// If quiz: require pass
		let canComplete = lessonUnlocked;
		if (kind === 'QUIZ') {
			const enr = this.state.enrollment;
			const score = enr && enr.progress && enr.progress.quiz ? enr.progress.quiz[l.Id] : undefined;
			canComplete = canComplete && !!(score && score.passed === true);
		}

		return (
			<div style={{ marginTop: 6, display: 'flex', gap: 8, alignItems: 'center' }}>
				<button
					disabled={completed || !canComplete}
					onClick={() => this.completeLesson(l)}
					title={completed ? 'Already completed' : canComplete ? 'Mark this lesson complete' : lessonUnlocked ? 'Pass the quiz to complete' : 'Complete the previous lesson (s)'}>
					{completed ? '✓ Completed' : 'Mark Complete'}
				</button>
				<button onClick={() => this.bookmarkLesson(l)} title='Bookmark this lesson'>
					⭐ Bookmark
				</button>
			</div>
		);
	}

	private async completeLesson(l: Lesson) {
		if (!this.canMarkLessonComplete(l)) {
			alert('Please complete previous lessons first.');
			return;
		}
		await this.saveProgress({ completed: [l.Id] });
		this.autoAdvance();
	}

	private canMarkLessonComplete(l: Lesson): boolean {
		const mId = l.ModuleId;
		let mObj: Module = null as any;
		for (let i = 0; i < this.state.modules.length; i++) {
			if (this.state.modules[i].Id === mId) {
				mObj = this.state.modules[i];
				break;
			}
		}
		if (!mObj || !this.isModuleUnlocked(mObj)) return false;

		const list = this.state.lessonsByModule[mId] || [];
		for (let j = 0; j < list.length; j++) {
			const item = list[j];
			if (item.Id === l.Id) break;
			if (!this.isLessonCompleted(item.Id)) return false;
		}
		return true;
	}

	private async bookmarkLesson(l: Lesson) {
		await this.saveProgress({ bookmarkLessonId: l.Id });
	}

	private autoAdvance() {
		const activeModuleId = this.state.activeModuleId;
		const activeLessonId = this.state.activeLessonId;
		const lessonsByModule = this.state.lessonsByModule;
		if (!activeModuleId || !activeLessonId) return;

		const list = lessonsByModule[activeModuleId] || [];
		let idx = -1;
		for (let i = 0; i < list.length; i++) {
			if (list[i].Id === activeLessonId) {
				idx = i;
				break;
			}
		}
		const next = idx >= 0 && idx < list.length - 1 ? list[idx + 1] : null;

		if (next) {
			this.setState({ activeLessonId: next.Id });
		} else {
			this.jumpToNextUnlockedModule();
		}
	}

	private jumpToNextUnlockedModule() {
		const { modules, activeModuleId, lessonsByModule } = this.state;
		if (!modules.length || !activeModuleId) return;

		const idx = modules.findIndex((m) => m.Id === activeModuleId);
		for (let i = idx + 1; i < modules.length; i++) {
			const m = modules[i];
			if (this.isModuleUnlocked(m)) {
				const first = (lessonsByModule[m.Id] || [])[0];
				if (first) {
					this.setState({ activeModuleId: m.Id, activeLessonId: first.Id });
					return;
				}
			} else break;
		}
	}

	private isModuleUnlocked(module: Module): boolean {
		const { modules, lessonsByModule } = this.state;

		let index = -1;
		for (let i = 0; i < modules.length; i++) {
			if (modules[i].Id === module.Id) {
				index = i;
				break;
			}
		}
		if (index <= 0) return true; // first module is unlocked

		for (let m = 0; m < index; m++) {
			const pm = modules[m];
			const lessons = lessonsByModule[pm.Id] || [];
			for (let k = 0; k < lessons.length; k++) {
				if (!this.isLessonCompleted(lessons[k].Id)) return false;
			}
		}
		return true;
	}

	private getVideoPosMap(): { [lessonId: number]: number } {
		const e = this.state.enrollment;
		if (e && e.progress && e.progress.videoPos) {
			return e.progress.videoPos;
		}
		return {};
	}

	private getSavedVideoTime(lessonId: number): number | null {
		const e = this.state.enrollment;
		const map = e && e.progress ? e.progress.videoPos : undefined;
		if (map && typeof map[lessonId] === 'number') return map[lessonId];
		return null;
	}

	private isLessonUnlockedInModule(moduleId: number, lessonId: number): boolean {
		const list = this.state.lessonsByModule[moduleId] || [];
		let idx = -1;
		for (let i = 0; i < list.length; i++) {
			if (list[i].Id === lessonId) {
				idx = i;
				break;
			}
		}
		if (idx <= 0) return true;

		for (let j = 0; j < idx; j++) {
			if (!this.isLessonCompleted(list[j].Id)) return false;
		}
		return true;
	}

	private async tryMarkCourseCompleted(progress: ProgressModel) {
		if (this.isPreview()) return;
		if (!this.state.enrollment) return;

		const allLessonsIds: number[] = this.getAllLessonIdsInCourse();
		if (!allLessonsIds.length) return;

		const completed = progress.completed || [];
		if (completed.length < allLessonsIds.length) return;

		let allDone = true;
		for (let i = 0; i < allLessonsIds.length; i++) {
			if (completed.indexOf(allLessonsIds[i]) === -1) {
				allDone = false;
				break;
			}
		}
		if (!allDone) return;

		try {
			const sp = getSP(this.props.context);
			const item = await sp.web.lists.getByTitle('CourseEnrollment').items.getById(this.state.enrollment.id).select('Id', 'Status', 'CompletedOn').get();

			const alreadyCompleted = item && item.Status === 'Completed' && item.CompletedOn;
			if (!alreadyCompleted) {
				await sp.web.lists.getByTitle('CourseEnrollment').items.getById(this.state.enrollment.id).update({
					Status: 'Completed',
					CompletedOn: new Date()
				});
			}
		} catch (err) {
			/* Done */
		}
	}

	private getAllLessonIdsInCourse(): number[] {
		const ids: number[] = [];
		const modules = this.state.modules;
		const byMod = this.state.lessonsByModule;
		for (let i = 0; i < modules.length; i++) {
			const m = modules[i];
			const list = byMod[m.Id] || [];
			for (let j = 0; j < list.length; j++) {
				ids.push(list[j].Id);
			}
		}

		return ids;
	}

	private isPreview(): boolean {
		// from prop
		const p: any = (this.props as any).preview;
		if (typeof p === 'string') {
			const s = p.toLowerCase();
			if (s === 'true' || s === '1' || s === 'yes') return true;
			if (s === 'false' || s === '0' || s === 'no') return false;
		}
		if (typeof p === 'boolean') return p === true;

		// fallback: ?preview=1|true
		const qs = (window.location.search || '').replace(/^\?/, '').split('&');
		for (let i = 0; i < qs.length; i++) {
			const kv = qs[i].split('=');
			if (decodeURIComponent(kv[0]) === 'preview') {
				const v = kv.length > 1 ? decodeURIComponent(kv[1]).toLowerCase() : '';
				return v === '1' || v === 'true' || v === 'yes';
			}
		}
		return false;
	}
}
