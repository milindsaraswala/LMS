/// <reference path="../../../../../@types/devExtreme/dx.all.d.ts" />
import 'devextreme';
import * as $ from 'jquery';
import * as React from 'react';
import { ContentKind, Course, Id, Lesson, Module } from '../common/models';
import { getSP } from '../common/pnp';
import { findIndexById, normKey, sanitizeHtml, toFieldUrlValue, upsertById } from '../common/utils';
import { AdminCoursePreview, LessonHtmlEditor, QuizEditor } from './';

type Props = { context: any };
type State = {
	loading: boolean;
	error?: string;

	courses: Course[];
	modules: Module[];
	lessons: Lesson[];

	newCourses: Course[];
	updCourses: Course[];
	delCourses: Id[];

	newModules: Module[];
	updModules: Module[];
	delModules: Id[];

	newLessons: Lesson[];
	updLessons: Lesson[];
	delLessons: Id[];

	htmlPopupVisible: boolean;
	editingLessonId?: number;

	quizPopupVisible: boolean;
};

const popupBackdropStyle: React.CSSProperties = {
	position: 'fixed',
	inset: 0,
	background: 'rgba(0,0,0,.35)',
	zIndex: 9999,
	display: 'flex',
	alignItems: 'center',
	justifyContent: 'center',
	padding: 12
};

const popupCardStyle: React.CSSProperties = {
	background: '#fff',
	width: '900px',
	maxWidth: '95vw',
	height: '700px',
	maxHeight: '90vh',
	boxShadow: '0 10px 30px rgba(0,0,0,.2)',
	borderRadius: 6,
	display: 'flex',
	flexDirection: 'column'
};

const popupHeaderStyle: React.CSSProperties = {
	display: 'flex',
	alignItems: 'center',
	padding: '8px 12px',
	borderBottom: '1px solid #eee'
};

export default class AdminBuilder extends React.Component<Props, State> {
	private coursesGridRef: HTMLDivElement = null as any;
	private modulesGridRef: HTMLDivElement = null as any;
	private lessonsGridRef: HTMLDivElement = null as any;

	private coursesDs: DevExpress.data.DataSource;
	private modulesDs: DevExpress.data.DataSource;
	private lessonsDs: DevExpress.data.DataSource;

	private _tempId = -1;

	constructor(props: Props) {
		super(props);
		this.state = {
			loading: true,

			courses: [],
			modules: [],
			lessons: [],

			newCourses: [],
			updCourses: [],
			delCourses: [],

			newModules: [],
			updModules: [],
			delModules: [],

			newLessons: [],
			updLessons: [],
			delLessons: [],

			htmlPopupVisible: false,
			editingLessonId: undefined,

			quizPopupVisible: false
		};

		this.coursesDs = this.buildCoursesDataSource();
		this.modulesDs = this.buildModulesDataSource();
		this.lessonsDs = this.buildLessonsDataSource();
	}

	public async componentDidMount() {
		try {
			await this.loadAll();
			this.setState({ loading: false }, () => {
				this.buildAllGrids();
			});
			window.addEventListener('message', this.onEditorMessage);
		} catch (e) {
			this.setState({ loading: false, error: e && e.message ? e.message : String(e) });
		}
	}

	public componentWillUnmount(): void {
		const cg = $(this.coursesGridRef).data('dxDataGrid');
		if (cg && cg.dispose) cg.dispose();

		const mg = $(this.modulesGridRef).data('dxDataGrid');
		if (mg && mg.dispose) mg.dispose();

		const lg = $(this.lessonsGridRef).data('dxDataGrid');
		if (lg && lg.dispose) lg.dispose();

		window.removeEventListener('message', this.onEditorMessage);
	}

	public render() {
		const qs = new URLSearchParams(window.location.search);
		if (qs.get('editHtml') === '1') {
			const lessonId = Number(qs.get('lessonId'));
			const returnUrl = qs.get('returnUrl');
			return <LessonHtmlEditor context={this.props.context} lessonId={lessonId} returnUrl={returnUrl} />;
		}

		if (qs.get('previewCourse') === '1') {
			const courseId = Number(qs.get('courseId'));
			return <AdminCoursePreview context={this.props.context} courseId={courseId} onBack={() => history.back()} />;
		}
		if (this.state.loading) return <div>Loading…</div>;
		if (this.state.error) return <div style={{ color: 'red' }}>Error: {this.state.error}</div>;

		return (
			<div>
				<h3>Admin Builder</h3>
				<p style={{ marginTop: 0 }}>
					Edit below, then click <b>Save changes</b>. All edits are kept in-memory until saved.
				</p>

				<h4>Courses</h4>
				<div ref={(el) => (this.coursesGridRef = el as any)} />

				<h4 style={{ marginTop: 24 }}>Modules</h4>
				<div ref={(el) => (this.modulesGridRef = el as any)} />

				<h4 style={{ marginTop: 24 }}>Lessons</h4>
				<div ref={(el) => (this.lessonsGridRef = el as any)} />

				<div style={{ marginTop: 24 }}>
					<button onClick={this.onSave}>Save changes</button>
				</div>
				{this.state.htmlPopupVisible && this.state.editingLessonId != null ? (
					<div style={popupBackdropStyle}>
						<div style={popupCardStyle}>
							<div style={popupHeaderStyle}>
								<div style={{ fontWeight: 600 }}>Edit Lesson HTML</div>
								<button onClick={this.closeHtmlEditor}>✕</button>
							</div>
							<div style={{ padding: 12, maxHeight: '70vh', overflow: 'auto' }}>
								<LessonHtmlEditor context={this.props.context} lessonId={this.state.editingLessonId} onSaved={this.onHtmlSaved} returnUrl={undefined} />
							</div>
						</div>
					</div>
				) : null}
				{this.state.quizPopupVisible && this.state.editingLessonId != null ? (
					<div style={popupBackdropStyle}>
						<div style={popupCardStyle}>
							<div style={popupHeaderStyle}>
								<div style={{ fontWeight: 600 }}>Edit Quiz</div>
								<button onClick={this.closeQuizEditor}>✕</button>
							</div>
							<div style={{ padding: 12, maxHeight: '70vh', overflow: 'auto' }}>
								<QuizEditor context={this.props.context} lessonId={this.state.editingLessonId} onSaved={this.onQuizSaved} returnUrl={undefined} />
							</div>
						</div>
					</div>
				) : null}
			</div>
		);
	}

	private onEditorMessage = (e: MessageEvent) => {
		if (e && e.data && e.data.type === 'lessonHtmlSaved') {
			this.lessonsDs.reload();
		}
	};

	private tempId() {
		return this._tempId--;
	}

	private async loadAll() {
		const sp = getSP(this.props.context);

		const [courses, modules, lessons] = await Promise.all([
			sp.web.lists.getByTitle('Courses').items.select('Id', 'Title', 'Code', 'Description', 'DurationMinutes', 'Level', 'Status', 'ThumbnailUrl').orderBy('Id', true).top(5000)(),

			sp.web.lists
				.getByTitle('Modules')
				.items.select('Id', 'Title', 'Order0', 'Description', 'CourseId', 'Course/Id')
				.expand('Course')
				.orderBy('Order0', true)
				.orderBy('Id', true)
				.top(5000)(),

			sp.web.lists
				.getByTitle('Lessons')
				.items.select('Id', 'Title', 'Order0', 'ContentTypeChoice', 'ContentUrl', 'HtmlContent', 'QuizJson', 'EstimatedMinutes', 'ModuleId', 'Module/Id')
				.expand('Module')
				.orderBy('ModuleId', true)
				.orderBy('Order0', true)
				.orderBy('Id', true)
				.top(5000)()
		]);

		const mCourses: Course[] = courses.map((c: Course) => ({
			Id: c.Id,
			Title: c.Title,
			Code: c.Code,
			Description: c.Description,
			DurationMinutes: c.DurationMinutes,
			Level: c.Level,
			Status: c.Status,
			ThumbnailUrl: c.ThumbnailUrl
		}));

		const mModules: Module[] = modules.map((m: Module) => ({
			Id: m.Id,
			Title: m.Title,
			Order0: m.Order0,
			Description: m.Description,
			CourseId: m.Course && m.Course.Id ? m.Course.Id : m.CourseId
		}));

		const mLessons: Lesson[] = lessons.map((l: Lesson) => ({
			Id: l.Id,
			Title: l.Title,
			ContentTypeChoice: l.ContentTypeChoice as ContentKind,
			ContentUrl: l.ContentUrl && (l.ContentUrl as any).Url ? (l.ContentUrl as any).Url : l.ContentUrl || '',
			HtmlContent: l.HtmlContent,
			QuizJson: l.QuizJson,
			EstimatedMinutes: l.EstimatedMinutes,
			Order0: l.Order0,
			ModuleId: l.Module && l.Module.Id ? l.Module.Id : l.ModuleId
		}));

		this.setState({ courses: mCourses, modules: mModules, lessons: mLessons });
	}

	private buildCoursesDataSource(): DevExpress.data.DataSource {
		return new DevExpress.data.DataSource({
			store: new DevExpress.data.CustomStore<any, any>({
				key: 'Id',
				load: async () => this.state.courses,
				byKey: (key: Id) => {
					const id = normKey(key);
					for (let i = 0; i < this.state.courses.length; i++) {
						if (this.state.courses[i].Id === id) return Promise.resolve(this.state.courses[i]);
					}
					return Promise.reject('not found');
				},
				insert: (values: Partial<Course>) => {
					return new Promise<number>((resolve) => {
						const newRow: Course = { Title: '', Status: 'Draft', ...values } as Course;
						newRow.Id = this.tempId();
						this.setState(
							(s) => ({
								courses: s.courses.concat([newRow]),
								newCourses: s.newCourses.concat([newRow])
							}),
							() => {
								this.refreshLookups();
								resolve(newRow.Id);
							}
						);
					});
				},
				update: (key: Id, values: Partial<Course>) => {
					return new Promise<void>((resolve, reject) => {
						const id = normKey(key);
						this.setState(
							(s) => {
								const idx = findIndexById(s.courses, id);
								if (idx < 0) {
									reject('not  found');
									return null;
								}
								const updated: any = Object.assign({}, s.courses[idx], values);
								const courses = s.courses.slice();
								courses[idx] = updated;

								const alreadyNew = findIndexById(s.newCourses, id) >= 0;
								const updCourses = alreadyNew ? s.updCourses : upsertById(s.updCourses, updated);
								return { courses, updCourses };
							},
							() => {
								this.refreshLookups();
								resolve();
							}
						);
					});
				},
				remove: (key: Id) => {
					return new Promise<void>((resolve) => {
						const id = normKey(key);
						this.setState(
							(s) => ({
								courses: s.courses.filter((x) => x.Id !== id),
								newCourses: s.newCourses.filter((x) => x.Id !== id),
								updCourses: s.updCourses.filter((x) => x.Id !== id),
								delCourses: id > 0 ? s.delCourses.concat([id]) : s.delCourses
							}),
							() => {
								this.refreshLookups();
								resolve();
							}
						);
					});
				}
			})
		});
	}

	private buildModulesDataSource(): DevExpress.data.DataSource {
		return new DevExpress.data.DataSource({
			store: new DevExpress.data.CustomStore<any, any>({
				key: 'Id',
				load: async () => this.state.modules,
				byKey: (key: Id) => {
					const id = normKey(key);
					for (let i = 0; i < this.state.modules.length; i++) {
						if (this.state.modules[i].Id === id) return Promise.resolve(this.state.modules[i]);
					}
					return Promise.reject('not found');
				},
				insert: (values: Partial<Module>) => {
					return new Promise<number>((resolve) => {
						const newRow: Module = { Title: '', CourseId: 0, Order0: 0, ...values } as Module;
						if (newRow.CourseId != null) newRow.CourseId = Number(newRow.CourseId);
						newRow.Id = this.tempId();
						this.setState(
							(s) => ({
								modules: s.modules.concat([newRow]),
								newModules: s.newModules.concat([newRow])
							}),
							() => {
								this.refreshLookups();
								resolve(newRow.Id);
							}
						);
					});
				},
				update: (key: Id, values: Partial<Module>) => {
					return new Promise<void>((resolve, reject) => {
						if (values.CourseId != null) values.CourseId = Number(values.CourseId);
						const id = normKey(key);
						this.setState(
							(s) => {
								const idx = findIndexById(s.modules, id);
								if (idx < 0) {
									reject('not  found');
									return null;
								}
								if (idx < 0) return null;
								const updated: any = Object.assign({}, s.modules[idx], values);
								const modules = s.modules.slice();
								modules[idx] = updated;

								const alreadyNew = findIndexById(s.newModules, id) >= 0;
								const updModules = alreadyNew ? s.updModules : upsertById(s.updModules, updated);
								return { modules, updModules };
							},
							() => {
								this.refreshLookups();
								resolve();
							}
						);
					});
				},
				remove: (key: Id) => {
					return new Promise<void>((resolve) => {
						const id = normKey(key);
						this.setState(
							(s) => ({
								modules: s.modules.filter((x) => x.Id !== id),
								newModules: s.newModules.filter((x) => x.Id !== id),
								updModules: s.updModules.filter((x) => x.Id !== id),
								delModules: id > 0 ? s.delModules.concat([id]) : s.delModules
							}),
							() => {
								this.refreshLookups();
								resolve();
							}
						);
					});
				}
			})
		});
	}

	private buildLessonsDataSource(): DevExpress.data.DataSource {
		return new DevExpress.data.DataSource({
			store: new DevExpress.data.CustomStore<any, any>({
				key: 'Id',
				load: () => Promise.resolve(this.state.lessons),
				byKey: (key: Id) => {
					const id = normKey(key);
					for (let i = 0; i < this.state.lessons.length; i++) {
						if (this.state.lessons[i].Id === id) return Promise.resolve(this.state.lessons[i]);
					}
					return Promise.reject('not found');
				},
				insert: (values: Partial<Lesson>) =>
					new Promise<number>((resolve) => {
						const newRow: Lesson = { Title: '', ModuleId: 0, Order0: 0, ContentTypeChoice: 'HTML', ...values } as Lesson;
						if (newRow.ModuleId != null) newRow.ModuleId = Number(newRow.ModuleId);
						newRow.Id = this.tempId();
						this.setState(
							(s) => ({
								lessons: s.lessons.concat([newRow]),
								newLessons: s.newLessons.concat([newRow])
							}),
							() => {
								this.refreshLookups();
								resolve(newRow.Id);
							}
						);
					}),
				update: (key: Id, values: Partial<Lesson>) => {
					return new Promise<void>((resolve, reject) => {
						if (values.ModuleId != null) values.ModuleId = Number(values.ModuleId);
						const id = normKey(key);
						this.setState(
							(s) => {
								const idx = findIndexById(s.lessons, id);
								if (idx < 0) {
									reject('not  found');
									return null;
								}
								const updated: any = Object.assign({}, s.lessons[idx], values);
								const lessons = s.lessons.slice();
								lessons[idx] = updated;

								const alreadyNew = findIndexById(s.newLessons, id) >= 0;
								const updLessons = alreadyNew ? s.updLessons : upsertById(s.updLessons, updated);
								return { lessons, updLessons };
							},
							() => {
								this.refreshLookups();
								resolve();
							}
						);
					});
				},
				remove: (key: Id) => {
					return new Promise<void>((resolve) => {
						const id = normKey(key);
						this.setState(
							(s) => ({
								lessons: s.lessons.filter((x) => x.Id !== id),
								newLessons: s.newLessons.filter((x) => x.Id !== id),
								updLessons: s.updLessons.filter((x) => x.Id !== id),
								delLessons: id > 0 ? s.delLessons.concat([id]) : s.delLessons
							}),
							() => {
								this.refreshLookups();
								resolve();
							}
						);
					});
				}
			})
		});
	}

	private buildAllGrids() {
		// Courses grid
		$(this.coursesGridRef).dxDataGrid({
			dataSource: this.coursesDs,
			showBorders: true,
			height: 300,
			editing: { mode: 'row', allowAdding: true, allowUpdating: true, allowDeleting: true, useIcons: true },
			columns: [
				{ dataField: 'Title', caption: 'Course Title', validationRules: [{ type: 'required' }] },
				{ dataField: 'Code', caption: 'Code', width: 120 },
				{ dataField: 'Level', caption: 'Level', lookup: { dataSource: ['Beginner', 'Intermediate', 'Advanced'] } },
				{ dataField: 'Status', caption: 'Status', width: 120, lookup: { dataSource: ['Draft', 'Published'] } },
				{
					dataField: 'DurationMinutes',
					caption: 'Duration (min)',
					width: 140,
					dataType: 'number',
					cellTemplate: (container: DevExpress.core.ElementWrapper<HTMLElement>, options: DevExpress.ui.dxDataGrid.ColumnCellTemplateData<any, any>) => {
						const courseId = options.data.Id;
						const sum = this.computeCourseMinutes(courseId);
						const val = Number(options.value) || 0;
						const mismatch = val !== sum;
						$('<div>')
							.text(val)
							.append(
								$('<span>')
									.css({ marginLeft: 6, fontSize: '12px', fontWeight: 700, color: mismatch ? '#b00020' : '#3a7' })
									.text(mismatch ? ` (≠ ${sum})` : ` (= ${sum})`)
							)
							.appendTo(container);
					}
				},
				{ dataField: 'ThumbnailUrl', caption: 'Thumbnail URL', width: 260 },
				{
					type: 'buttons',
					buttons: [
						{ name: 'edit', hint: 'Edit Course' },
						{ name: 'save', hint: 'Save Course' },
						{ name: 'cancel', hint: 'Cancel Course' },
						{ name: 'delete', hint: 'Delete Course' },
						{
							icon: 'check',
							hint: 'Publish Course',
							onClick: (e) => {
								const id = e.row && e.row.data ? e.row.data.Id : 0;
								if (!id || id < 1) {
									alert('Please save the course first before publishing.');
									return;
								}
								this.publishCourse(id);
							}
						},
						{
							text: 'Preview',
							icon: 'search',
							hint: 'Preview Course',
							onClick: (e) => {
								const id = e.row && e.row.data ? e.row.data.Id : 0;
								if (!id) return;
								const url = `${location.pathname}?previewCourse=1&courseId=${id}`;
								window.location.href = url;
							}
						}
					]
				}
			],
			onRowInserted: () => (this.modulesDs as any).reload(),
			onRowUpdated: () => (this.modulesDs as any).reload(),
			onRowRemoved: () => {
				this.setState((s) => {
					const keptModules = s.modules.filter((m) => s.courses.some((c) => c.Id === m.CourseId));
					const keptLessons = s.lessons.filter((l) => keptModules.some((m) => m.Id === l.ModuleId));
					return { modules: keptModules, lessons: keptLessons };
				});
				(this.modulesDs as any).reload();
				(this.lessonsDs as any).reload();
			},
			onEditingStart: (e: DevExpress.ui.dxDataGrid.EditingStartEvent<any, any>) => {
				if (e.data && e.data.Status === 'Published') {
					e.cancel = true;
					DevExpress.ui.notify('Published course are locked. Unpublish to edit.', 'warning', 2000);
				}
			}
		});

		// Modules grid
		$(this.modulesGridRef).dxDataGrid({
			dataSource: this.modulesDs,
			showBorders: true,
			height: 320,
			editing: { mode: 'row', allowAdding: true, allowUpdating: true, allowDeleting: true, useIcons: true },
			columns: [
				{ dataField: 'Title', caption: 'Module Title', validationRules: [{ type: 'required' }] },
				{
					dataField: 'CourseId',
					caption: 'Course',
					setCellValue(newData, value) {
						newData.CourseId = value == null ? null : Number(value);
					},
					lookup: {
						dataSource: this.state.courses,
						valueExpr: 'Id',
						displayExpr: 'Title'
					},
					width: 240,
					validationRules: [{ type: 'required' }]
				},
				{ dataField: 'Order0', caption: 'Order', dataType: 'number', width: 100 },
				{ dataField: 'Description', caption: 'Description' },
				{
					type: 'buttons',
					buttons: [
						{ name: 'edit', hint: 'Edit Module' },
						{ name: 'save', hint: 'Save Module' },
						{ name: 'cancel', hint: 'Cancel Module' },
						{ name: 'delete', hint: 'Delete Module' }
					]
				}
			],
			onEditorPreparing: (e: DevExpress.ui.dxDataGrid.EditorPreparingEvent<any, any>) => {
				if (e.parentType === 'dataRow' && e.dataField === 'CourseId') {
					e.editorOptions = e.editorOptions || {};
					e.editorOptions.dataSource = this.state.courses;
					e.editorOptions.valueExpr = 'Id';
					e.editorOptions.displayExpr = 'Title';
					e.editorOptions.searchEnabled = true;
					e.editorOptions.openOnFieldClick = true;
				}
			},
			onRowInserted: () => (this.lessonsDs as any).reload(),
			onRowUpdated: () => (this.lessonsDs as any).reload(),
			onRowRemoved: () => {
				this.setState((s) => {
					const keptLessons = s.lessons.filter((l) => s.modules.some((m) => m.Id === l.ModuleId));
					return { lessons: keptLessons };
				});
				(this.lessonsDs as any).reload();
			}
		});

		// Lessons grid
		$(this.lessonsGridRef).dxDataGrid({
			dataSource: this.lessonsDs,
			width: '100%',
			wordWrapEnabled: true,
			showBorders: true,
			height: 360,
			columnAutoWidth: false,
			scrolling: { mode: 'standard' },
			editing: { mode: 'row', allowAdding: true, allowUpdating: true, allowDeleting: true, useIcons: true },
			rowDragging: {
				allowReordering: true,
				onReorder: (e) => {
					const from = e.fromIndex,
						to = e.toIndex;
					const all = this.state.lessons.slice();
					const row = all.splice(from, 1)[0];
					all.splice(to, 0, row);

					for (let i = 0; i < all.length; i++) all[i].Order0 = i + 1;

					this.setState((s) => ({
						lessons: all,
						updLessons: all.reduce((acc, l) => upsertById(acc, l), s.updLessons)
					}));

					e.component.refresh();
				}
			},
			summary: {
				totalItems: [
					{
						column: 'EstimatedMinutes',
						summaryType: 'sum',
						displayFormat: 'Total: {0}'
					}
				]
			},
			columns: [
				{ dataField: 'Title', caption: 'Lesson Title', validationRules: [{ type: 'required' }] },
				{
					dataField: 'ModuleId',
					caption: 'Module',
					lookup: {
						dataSource: this.state.modules,
						valueExpr: 'Id',
						displayExpr: 'Title'
					},
					width: 240,
					validationRules: [{ type: 'required' }],
					setCellValue(newData, value) {
						newData.ModuleId = value == null ? null : Number(value);
					}
				},
				{ dataField: 'Order0', caption: 'Order', dataType: 'number', width: 90 },
				{
					dataField: 'ContentTypeChoice',
					caption: 'Type',
					width: 120,
					lookup: { dataSource: ['PDF', 'PPT', 'Video', 'Audio', 'Link', 'HTML', 'Quiz'] }
				},
				{
					dataField: 'ContentUrl',
					caption: 'Content URL',
					width: 280,
					visible: true,
					cellTemplate: (container: any, options: any) => {
						const el: HTMLElement = container && container.get ? container.get(0) : container;

						while (el.firstChild) el.removeChild(el.firstChild);
						const url = String(options.value || '').trim();
						if (!url) return;

						const a = document.createElement('a');
						a.href = url;
						a.target = '_blank';
						a.title = url;
						a.textContent = url;
						a.style.display = 'inline-block';
						a.style.maxWidth = '100%';
						a.style.whiteSpace = 'normal';
						(a.style as any).wordBreak = 'break-word';
						(a.style as any).overflowWrap = 'anywhere';
						el.appendChild(a);
					}
				},
				{ dataField: 'EstimatedMinutes', caption: 'Est. (min)', dataType: 'number', width: 110 },
				{
					type: 'buttons',
					buttons: [
						{ name: 'edit', hint: 'Edit Lesson' },
						{ name: 'save', hint: 'Save Lesson' },
						{ name: 'cancel', hint: 'Cancel Lesson' },
						{ name: 'delete', hint: 'Delete Lesson' },
						{
							hint: 'Edit HTML',
							text: 'Lesson Edit',
							icon: 'codeblock',
							visible: (e) => e.row && e.row.data && e.row.data.ContentTypeChoice === 'HTML',
							onClick: (e) => {
								const id = e.row.data.Id;
								this.openHtmlEditor(id);
								// const returnUrl = encodeURIComponent(window.location.href);
								// const url = `${location.pathname}?editHtml=1&lessonId=${id}&returnUrl=${returnUrl}`;
								// window.open(url, '_blank');
							}
						},
						{
							icon: 'preferences',
							hint: 'Edit Quiz',
							visible: (e) => e.row && e.row.data && e.row.data.ContentTypeChoice === 'Quiz',
							onClick: (e) => {
								this.openQuizEditor(e.row.data.Id);
							}
						}
					]
				}
			],
			onEditorPreparing: (e: DevExpress.ui.dxDataGrid.EditorPreparingEvent<any, any>) => {
				if (e.parentType === 'dataRow' && e.dataField === 'ContentUrl') {
					const ct = (e.row && e.row.data && e.row.data.ContentTypeChoice) || 'HTML';
					e.editorOptions = e.editorOptions || {};
					e.editorOptions.disabled = ct === 'HTML' || ct === 'Quiz';
				}
				if (e.parentType === 'dataRow' && e.dataField === 'HTMLContent') {
					const ct = (e.row && e.row.data && e.row.data.ContentTypeChoice) || 'HTML';
					e.cancel = ct !== 'HTML';
				}
				if (e.parentType === 'dataRow' && e.dataField === 'ModuleId') {
					e.editorOptions = e.editorOptions || {};
					e.editorOptions.dataSource = this.state.modules;
					e.editorOptions.valueExpr = 'Id';
					e.editorOptions.displayExpr = 'Title';
					e.editorOptions.searchEnabled = true;
					e.editorOptions.openOnFieldClick = true;
				}
			}
		});
	}

	private commitAllEdits = async () => {
		const trySave = async (ref: HTMLDivElement) => {
			const inst: any = $(ref).dxDataGrid('instance');
			if (inst && typeof inst.saveEditData === 'function') {
				const r = inst.saveEditData();
				if (r && typeof r.then === 'function') await r;
			}
		};
		await trySave(this.coursesGridRef);
		await trySave(this.modulesGridRef);
		await trySave(this.lessonsGridRef);
	};

	private onSave = async () => {
		const sp = getSP(this.props.context);

		try {
			await this.commitAllEdits();

			const coursesList = sp.web.lists.getByTitle('Courses');
			const addCoursePromises: Promise<any>[] = [];
			const courseTempToReal: Record<number, number> = {};

			for (const c of this.state.newCourses) {
				addCoursePromises.push(
					coursesList.items
						.add({
							Title: c.Title,
							Code: c.Code,
							Description: c.Description,
							DurationMinutes: c.DurationMinutes,
							Level: c.Level,
							Status: c.Status,
							ThumbnailUrl: c.ThumbnailUrl
						})
						.then((res) => {
							courseTempToReal[(c.Id as any) as number] = res.data.Id;
						})
				);
			}
			await Promise.all(addCoursePromises);

			const stagedNewModules = this.state.newModules.map((m) => {
				const isTempParent = (m.CourseId as any) < 0;
				return isTempParent ? { ...m, CourseId: courseTempToReal[(m.CourseId as any) as number] } : m;
			});

			const modulesList = sp.web.lists.getByTitle('Modules');
			const addModulePromises: Promise<any>[] = [];
			const moduleTempToReal: Record<number, number> = {};

			for (const m of stagedNewModules) {
				addModulePromises.push(
					modulesList.items
						.add({
							Title: m.Title,
							Order0: m.Order0,
							Description: m.Description,
							CourseId: m.CourseId
						})
						.then((res) => {
							moduleTempToReal[(m.Id as any) as number] = res.data.Id;
						})
				);
			}
			await Promise.all(addModulePromises);

			const stagedNewLessons = this.state.newLessons.map((l) => {
				const isTempParent = (l.ModuleId as any) < 0;
				return isTempParent ? { ...l, ModuleId: moduleTempToReal[(l.ModuleId as any) as number] } : l;
			});

			const lessonsList = sp.web.lists.getByTitle('Lessons');
			const addLessonPromises: Promise<any>[] = [];

			for (const l of stagedNewLessons) {
				const cleanHtml = sanitizeHtml(l.HtmlContent);
				addLessonPromises.push(
					lessonsList.items.add({
						Title: l.Title,
						Order0: l.Order0,
						ContentTypeChoice: l.ContentTypeChoice,
						ContentUrl: toFieldUrlValue(l.ContentUrl),
						HtmlContent: cleanHtml,
						QuizJson: l.QuizJson,
						EstimatedMinutes: l.EstimatedMinutes,
						ModuleId: l.ModuleId
					})
				);
			}
			await Promise.all(addLessonPromises);

			const updCoursePromises: Promise<any>[] = [];
			for (const c of this.state.updCourses) {
				if (!c.Id || c.Id < 1) continue;
				updCoursePromises.push(
					coursesList.items.getById(c.Id).update({
						Title: c.Title,
						Code: c.Code,
						Description: c.Description,
						DurationMinutes: c.DurationMinutes,
						Level: c.Level,
						Status: c.Status,
						ThumbnailUrl: c.ThumbnailUrl
					})
				);
			}

			const updModulePromises: Promise<any>[] = [];
			for (const m0 of this.state.updModules) {
				if (!m0.Id || m0.Id < 1) continue;
				const m = (m0.CourseId as any) < 0 ? { ...m0, CourseId: courseTempToReal[(m0.CourseId as any) as number] } : m0;

				updModulePromises.push(
					modulesList.items.getById(m.Id!).update({
						Title: m.Title,
						Order0: m.Order0,
						Description: m.Description,
						CourseId: m.CourseId
					})
				);
			}

			const updLessonPromises: Promise<any>[] = [];
			for (const l0 of this.state.updLessons) {
				if (!l0.Id || l0.Id < 1) continue;
				const cleanHtml = sanitizeHtml(l0.HtmlContent);
				const l = (l0.ModuleId as any) < 0 ? { ...l0, ModuleId: moduleTempToReal[(l0.ModuleId as any) as number] } : l0;

				updLessonPromises.push(
					lessonsList.items.getById(l.Id!).update({
						Title: l.Title,
						Order0: l.Order0,
						ContentTypeChoice: l.ContentTypeChoice,
						ContentUrl: toFieldUrlValue(l.ContentUrl),
						HtmlContent: cleanHtml,
						QuizJson: l.QuizJson,
						EstimatedMinutes: l.EstimatedMinutes,
						ModuleId: l.ModuleId
					})
				);
			}

			await Promise.all([...updCoursePromises, ...updModulePromises, ...updLessonPromises]);

			const delLessonPromises = this.state.delLessons.map((id) => lessonsList.items.getById(id).delete());
			await Promise.all(delLessonPromises);

			const delModulePromises = this.state.delModules.map((id) => modulesList.items.getById(id).delete());
			await Promise.all(delModulePromises);

			const delCoursePromises = this.state.delCourses.map((id) => coursesList.items.getById(id).delete());
			await Promise.all(delCoursePromises);

			await this.loadAll();
			const mg: any = $(this.modulesGridRef).dxDataGrid('instance');
			if (mg) {
				mg.columnOption('CourseId', 'lookup.dataSource', this.state.courses);
				mg.repaint();
			}
			const lg: any = $(this.lessonsGridRef).dxDataGrid('instance');
			if (lg) {
				lg.columnOption('ModuleId', 'lookup.dataSource', this.state.modules);
				lg.repaint();
			}

			// clear diffs
			this.setState({
				newCourses: [],
				updCourses: [],
				delCourses: [],
				newModules: [],
				updModules: [],
				delModules: [],
				newLessons: [],
				updLessons: [],
				delLessons: []
			});

			alert('Saved successfully.');
		} catch (e) {
			alert('Save failed: ' + (e && (e as any).message ? (e as any).message : String(e)));
		}
	};

	private refreshLookups = () => {
		const mg: DevExpress.ui.dxDataGrid = $(this.modulesGridRef).dxDataGrid('instance');
		if (mg) {
			mg.columnOption('CourseId', 'lookup.dataSource', this.state.courses);
			mg.repaint();
		}

		const lg: DevExpress.ui.dxDataGrid = $(this.lessonsGridRef).dxDataGrid('instance');
		if (lg) {
			lg.columnOption('ModuleId', 'lookup.dataSource', this.state.modules);
			lg.repaint();
		}
	};

	private openHtmlEditor = (lessonId: number) => {
		this.setState({ htmlPopupVisible: true, editingLessonId: lessonId });
	};

	private closeHtmlEditor = () => {
		this.setState({ htmlPopupVisible: false, editingLessonId: undefined });
	};

	private onHtmlSaved = () => {
		this.lessonsDs.reload();
		this.closeHtmlEditor();
	};

	private computeCourseMinutes = (courseId: number) => {
		const moduleIds = this.state.modules.filter((m) => m.CourseId === courseId).map((m) => m.Id);
		const total = this.state.lessons.filter((l) => moduleIds.indexOf(l.ModuleId) >= 0).reduce((sum, l) => sum + (Number(l.EstimatedMinutes) || 0), 0);
		return total;
	};

	private validateCourse = (courseId: number): { ok: boolean; issues: string[]; computedMinutes: number } => {
		const issues: string[] = [];
		const c = this.state.courses.find((x) => x.Id === courseId);
		if (!c) return { ok: false, issues: ['Course not found in current state.'], computedMinutes: 0 };

		const mods = this.state.modules.filter((m) => m.CourseId === courseId);
		if (mods.length === 0) issues.push('No modules under this course.');

		const modIdSet = new Set(mods.map((m) => m.Id));
		const lessonsByMod = new Map<number, number>();
		const lessons = this.state.lessons.filter((l) => modIdSet.has(l.ModuleId));
		lessons.forEach((l) => lessonsByMod.set(l.ModuleId, (lessonsByMod.get(l.ModuleId) || 0) + 1));

		// Each module must have ≥1 lesson
		for (const m of mods) {
			if (!lessonsByMod.get(m.Id)) {
				issues.push(`Module "${m.Title}" has no lessons.`);
			}
		}

		// Lesson content checks
		for (const l of lessons) {
			const t = (l.ContentTypeChoice || 'HTML').toUpperCase();
			if (t === 'HTML') {
				const html = (l.HtmlContent || '').trim();
				if (!html) issues.push(`Lesson "${l.Title}" (HTML) has empty content.`);
			} else if (t === 'QUIZ') {
				try {
					const q = l.QuizJson ? JSON.parse(l.QuizJson) : null;
					if (!q || !Array.isArray(q.questions) || q.questions.length === 0) {
						issues.push(`Lesson "${l.Title}" (Quiz) has no questions.`);
					}
				} catch {
					issues.push(`Lesson "${l.Title}" (Quiz) has invalid QuizJson.`);
				}
			} else {
				if (!l.ContentUrl) issues.push(`Lesson "${l.Title}" (${t}) missing Content URL.`);
			}
		}

		const byMod: { [mid: number]: number[] } = {};
		for (const l of lessons) {
			byMod[l.ModuleId] = byMod[l.ModuleId] || [];
			byMod[l.ModuleId].push(Number(l.Order0) || 0);
		}
		Object.keys(byMod).forEach((k) => {
			const arr = byMod[Number(k)].slice().sort((a, b) => a - b);
			for (let i = 0; i < arr.length; i++) {
				if (arr[i] !== i + 1) {
					const m = mods.find((mm) => mm.Id === Number(k));
					issues.push(`Module "${m ? m.Title : k}" lesson order has gaps (expected 1..N).`);
					break;
				}
			}
		});

		const computedMinutes = this.computeCourseMinutes(courseId);
		if ((Number(c.DurationMinutes) || 0) !== computedMinutes) {
			issues.push(`Duration mismatch: Course=${c.DurationMinutes || 0} vs Sum of lessons=${computedMinutes}.`);
		}

		return { ok: issues.length === 0, issues, computedMinutes };
	};

	private publishCourse = async (courseId: number) => {
		const sp = getSP(this.props.context);

		try {
			await this.commitAllEdits();

			const res = this.validateCourse(courseId);
			if (!res.ok) {
				const otherIssues = res.issues.filter((i) => (i.indexOf('Duration mismatch:') !== 0 ? true : false));
				if (otherIssues.length > 0) {
					alert('Cannot publish:\n\n' + res.issues.map((x) => '• ' + x).join('\n'));
					return;
				}

				const fix = confirm(
					`Duration mismatch.\n\nCourse Duration: ${this.state.courses.find((c) => c.Id === courseId).DurationMinutes || 0}\nSum of Lessons: ${res.computedMinutes}\n\n` +
						`Click OK to auto-update Course Duration to ${res.computedMinutes} and publish.\nClick Cancel to abort.`
				);
				if (!fix) return;

				await sp.web.lists.getByTitle('Courses').items.getById(courseId).update({
					DurationMinutes: res.computedMinutes
				});
			}

			await sp.web.lists.getByTitle('Courses').items.getById(courseId).update({
				Status: 'Published'
			});

			await this.loadAll();

			const mg: any = $(this.modulesGridRef).dxDataGrid('instance');
			if (mg) {
				mg.columnOption('CourseId', 'lookup.dataSource', this.state.courses);
				mg.repaint();
			}
			const lg: any = $(this.lessonsGridRef).dxDataGrid('instance');
			if (lg) {
				lg.columnOption('ModuleId', 'lookup.dataSource', this.state.modules);
				lg.repaint();
			}

			alert('Course published successfully.');
		} catch (e) {
			alert('Publish failed: ' + (e && (e as any).message ? (e as any).message : String(e)));
		}
	};

	private openQuizEditor = (lessonId: number) => {
		this.setState({ quizPopupVisible: true, editingLessonId: lessonId });
	};

	private closeQuizEditor = () => {
		this.setState({ quizPopupVisible: false, editingLessonId: undefined });
	};

	private onQuizSaved = () => {
		this.lessonsDs.reload();
		this.closeQuizEditor();
	};
}
