import { WebPartContext } from "@microsoft/sp-webpart-base";
import { INintexOutcome, INintexTask } from "../models/INintexTask";
import { SPHttpClient } from "@microsoft/sp-http";

export default class NintexWorkflowService {
  private context: WebPartContext;
  private siteUrl: string;

  constructor(context: WebPartContext) {
    this.context = context;
    this.siteUrl = context.pageContext.web.absoluteUrl;
  }

  /* ============================
     EXISTING METHODS (UNCHANGED)
     ============================ */

  public async getRunningTask(
    listName: string,
    itemId: number
  ): Promise<INintexTask | null> {

    const soapBody =
      "<?xml version='1.0' encoding='utf-8'?>" +
      "<soap:Envelope xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' " +
      "xmlns:xsd='http://www.w3.org/2001/XMLSchema' " +
      "xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/'>" +
      "<soap:Body>" +
      "<GetRunningWorkflowTasksForCurrentUserForListItem xmlns='http://nintex.com'>" +
      "<itemId>" + itemId + "</itemId>" +
      "<listName>" + listName + "</listName>" +
      "</GetRunningWorkflowTasksForCurrentUserForListItem>" +
      "</soap:Body>" +
      "</soap:Envelope>";

    const response = await fetch(
      this.siteUrl + "/_vti_bin/NintexWorkflow/workflow.asmx",
      {
        method: "POST",
        headers: {
          "Content-Type": "text/xml; charset=utf-8",
          "SOAPAction":
            "http://nintex.com/GetRunningWorkflowTasksForCurrentUserForListItem"
        },
        body: soapBody
      }
    );

    const text = await response.text();
    const xml = new DOMParser().parseFromString(text, "text/xml");

    const taskNodes = xml.getElementsByTagName("UserTask");
    if (!taskNodes || taskNodes.length === 0) {
      return null;
    }

    const task = taskNodes[0];

    return {
      sharePointTaskId: parseInt(
        task.getElementsByTagName("SharePointTaskId")[0].textContent,
        10
      ),
      taskName: task.getElementsByTagName("TaskName")[0].textContent,
      taskType: task.getElementsByTagName("TaskType")[0].textContent,
      taskListName: "Workflow Tasks"
    };
  }

  public async getFlexiTaskOutcomes(
    taskId: number,
    taskListName: string
  ): Promise<INintexOutcome[]> {

    const soapBody =
      "<?xml version='1.0' encoding='utf-8'?>" +
      "<soap:Envelope xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' " +
      "xmlns:xsd='http://www.w3.org/2001/XMLSchema' " +
      "xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/'>" +
      "<soap:Body>" +
      "<GetOutcomesForFlexiTask xmlns='http://nintex.com'>" +
      "<spTaskId>" + taskId + "</spTaskId>" +
      "<taskListName>" + taskListName + "</taskListName>" +
      "</GetOutcomesForFlexiTask>" +
      "</soap:Body>" +
      "</soap:Envelope>";

    const response = await fetch(
      this.siteUrl + "/_vti_bin/NintexWorkflow/workflow.asmx",
      {
        method: "POST",
        headers: {
          "Content-Type": "text/xml; charset=utf-8",
          "SOAPAction": "http://nintex.com/GetOutcomesForFlexiTask"
        },
        body: soapBody
      }
    );

    const text = await response.text();
    const xml = new DOMParser().parseFromString(text, "text/xml");

    const outcomeNodes = xml.getElementsByTagName("ConfiguredOutcome");
    const results: INintexOutcome[] = [];

    for (let i = 0; i < outcomeNodes.length; i++) {
      const n = outcomeNodes[i];

      results.push({
        id: parseInt(n.getAttribute("Id"), 10),
        name: n.getAttribute("Name"),
        commentMode: n.getAttribute("CommentMode") as any
      });
    }

    return results;
  }

  public async completeFlexiTask(
    taskId: number,
    outcome: string,
    comment: string,
    taskListName: string
  ): Promise<void> {

    const soapBody =
      "<?xml version='1.0' encoding='utf-8'?>" +
      "<soap:Envelope xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' " +
      "xmlns:xsd='http://www.w3.org/2001/XMLSchema' " +
      "xmlns:soap='http://schemas.xmlsoap.org/soap/envelope/'>" +
      "<soap:Body>" +
      "<ProcessFlexiTaskResponse xmlns='http://nintex.com'>" +
      "<comments>" + (comment || "") + "</comments>" +
      "<outcome>" + outcome + "</outcome>" +
      "<spTaskId>" + taskId + "</spTaskId>" +
      "<taskListName>" + taskListName + "</taskListName>" +
      "</ProcessFlexiTaskResponse>" +
      "</soap:Body>" +
      "</soap:Envelope>";

    await fetch(
      this.siteUrl + "/_vti_bin/NintexWorkflow/workflow.asmx",
      {
        method: "POST",
        headers: {
          "Content-Type": "text/xml; charset=utf-8",
          "SOAPAction": "http://nintex.com/ProcessFlexiTaskResponse"
        },
        body: soapBody
      }
    );
  }

  /* ==================================
     NEW METHOD (USE THIS FROM UI)
     ================================== */

  public async completeTaskWithHistory(params: {
    task: INintexTask;
    outcome: string;
    comment: string;
    caseItemId: number;
    caseId: string;
  }): Promise<void> {

    if (!params.comment || !params.comment.trim()) {
      throw new Error("Comment is mandatory.");
    }

    // 1️⃣ Complete Nintex task
    await this.completeFlexiTask(
      params.task.sharePointTaskId,
      params.outcome,
      params.comment,
      params.task.taskListName
    );

    // 2️⃣ Log history AFTER success
    await this.logActionHistory({
      caseItemId: params.caseItemId,
      caseId: params.caseId,
      taskId: params.task.sharePointTaskId,
      taskName: params.task.taskName,
      action: params.outcome,
      comment: params.comment
    });
  }

  /* ============================
     PRIVATE – HISTORY LOGGING
     ============================ */

  private async logActionHistory(data: {
    caseItemId: number;
    caseId: string;
    taskId: number;
    taskName: string;
    action: string;
    comment: string;
  }): Promise<void> {

    const url =
      this.siteUrl +
      "/_api/web/lists/getbytitle('DisputeCaseActionHistory')/items";

    await this.context.spHttpClient.post(
      url,
      SPHttpClient.configurations.v1,
      {
        headers: {
          "Accept": "application/json;odata=nometadata",
          "Content-Type": "application/json;odata=nometadata"
        },
        body: JSON.stringify({
          Title: data.action,
          CaseItemId: data.caseItemId,
          CaseId: data.caseId,
          TaskId: data.taskId,
          TaskName: data.taskName,
          Action: data.action,
          Comment: data.comment
        })
      }
    );
  }
}