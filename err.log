// ---- PATH + FOLDER HELPERS ----

// Get the library root folder object by server-relative path (works even when baseUrl is root web)
private async getCourseAssetsRoot() {
  const sp = getSP(this.props.context);
  // Throws 404 immediately if library path is wrong
  const rootFolder = sp.web.getFolderByServerRelativePath(COURSE_ASSETS_LIB_SERVER_REL);
  // Touch it to ensure it exists and fetch the canonical path
  const meta = await rootFolder.select('ServerRelativeUrl')();
  const libSrvRel: string = meta.ServerRelativeUrl; // e.g. "/lms/CourseAssets"
  return { rootFolder, libSrvRel };
}

// Create child folders **under the given Folder** (each segment is just a name, NO leading slash)
private async ensureNestedFolder(parent: any, segments: string[]): Promise<any> {
  let current = parent;
  for (let i = 0; i < segments.length; i++) {
    const seg = (segments[i] || '').trim();
    if (!seg) continue;
    try {
      const child = current.folders.getByName(seg);
      await child.select('ServerRelativeUrl')();
      current = child;
    } catch {
      await current.folders.addUsingPath(seg);      // <- child name only
      current = current.folders.getByName(seg);
    }
  }
  return current;
}

private buildLessonFolderSegments(lessonId: number): string[] {
  if (!NEST_BY_COURSE_AND_MODULE) return [];
  const lesson = this.state.lessons.find((l) => l.Id === lessonId);
  if (!lesson) return [];
  const mod = this.state.modules.find((m) => m.Id === lesson.ModuleId);
  const courseId = mod && typeof mod.CourseId === 'number' ? mod.CourseId : null;

  const segs: string[] = ['Courses'];
  if (courseId != null) segs.push(String(courseId));
  if (mod) segs.push('Modules', String(mod.Id));
  return segs;
}

private sanitizeFileName(name: string): string {
  // Keep it simple: strip characters SharePoint dislikes in folder/file names
  return (name || '').replace(/[<>:"|?*\\/#{}%~&]/g, '_').replace(/\s+/g, ' ').trim();
}
// ---- UPLOAD ----
private async uploadToLibrary(file: File, lessonId: number): Promise<{ serverRelativeUrl: string; absoluteUrl: string }> {
  const sp = getSP(this.props.context);

  // For absolute URL
  const webInfo: any = await sp.web.select('Url')();
  const webAbs: string = (webInfo.Url || '').replace(/\/+$/, '');

  const { rootFolder, libSrvRel } = await this.getCourseAssetsRoot();

  // Ensure target folder under /lms/CourseAssets
  const segs = this.buildLessonFolderSegments(lessonId);
  const targetFolder = await this.ensureNestedFolder(rootFolder, segs);

  const safeName = this.sanitizeFileName(file.name);

  // PnPjs v3 (works in v2 with slight polyfills; we also provide a fallback below)
  if (typeof targetFolder.files.addUsingPath === 'function') {
    const addRes = await targetFolder.files.addUsingPath(safeName, file, { Overwrite: true });
    const item = await addRes.file.getItem();
    const props: any = await item.select('FileRef')();
    const srl: string = props && props.FileRef ? props.FileRef : `${libSrvRel}/${[...segs, safeName].join('/')}`.replace(/\/+/g, '/');
    return { serverRelativeUrl: srl, absoluteUrl: webAbs + srl };
  }

  // Fallback (older pnpjs): add(name, contents, overwrite)
  // @ts-ignore
  const addResV2 = await targetFolder.files.add(safeName, file, true);
  // @ts-ignore
  const itemV2 = await addResV2.file.getItem();
  // @ts-ignore
  const propsV2: any = await itemV2.select('FileRef')();
  const srl2: string = propsV2 && propsV2.FileRef ? propsV2.FileRef : `${libSrvRel}/${[...segs, safeName].join('/')}`.replace(/\/+/g, '/');
  return { serverRelativeUrl: srl2, absoluteUrl: webAbs + srl2 };
}
// ---- BUTTON HANDLER (unchanged idea) ----
private openUploadForLesson = (lessonId: number) => {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '*/*';
  input.onchange = async () => {
    if (!input.files || !input.files.length) return;
    try {
      const file = input.files[0];
      const { absoluteUrl } = await this.uploadToLibrary(file, lessonId);

      this.setState((s) => {
        const idx = s.lessons.findIndex((l) => l.Id === lessonId);
        if (idx < 0) return s as any;
        const updated = { ...s.lessons[idx], ContentUrl: absoluteUrl };
        const lessons = s.lessons.slice();
        lessons[idx] = updated;
        const updLessons = upsertById(s.updLessons, updated);
        return { lessons, updLessons } as any;
      });

      DevExpress.ui.notify('File uploaded and URL set.', 'success', 2000);
    } catch (err) {
      const msg = err && (err as any).message ? (err as any).message : String(err);
      DevExpress.ui.notify('Upload failed: ' + msg, 'error', 4000);
    }
  };
  input.click();
};
