private async uploadToLibrary(file: File, lessonId: number): Promise<{ serverRelativeUrl: string; absoluteUrl: string; }> {
  const sp = getSP(this.props.context);

  // Web info to assemble server-relative + absolute URLs
  const webInfo: any = await sp.web.select('ServerRelativeUrl', 'Url')();
  const webServerRel: string = webInfo.ServerRelativeUrl || '/';
  const webAbs: string = (webInfo.Url || '').replace(/\/+$/, '');

  // Build the base library server-relative path.
  // If COURSE_ASSETS_LIB starts with '/', assume it's already server-relative; otherwise join to web root.
  const baseLibSrvRel =
    COURSE_ASSETS_LIB.charAt(0) === '/'
      ? COURSE_ASSETS_LIB
      : (webServerRel.replace(/\/+$/, '') + '/' + COURSE_ASSETS_LIB).replace(/\/+/g, '/');

  // Resolve nested folder path (ensure it exists)
  const targetFolderSrvRel = await this.resolveTargetFolderServerRelative(baseLibSrvRel, lessonId);

  const overwrite = true;
  const folder = sp.web.getFolderByServerRelativePath(targetFolderSrvRel);
  const addRes = await folder.files.addUsingPath(file.name, file, { Overwrite: overwrite }); // works in pnpjs v3; for v2 use folder.files.add

  // Get server-relative of the uploaded file
  const fileItem = await addRes.file.getItem();
  const fileProps: any = await fileItem.select('FileRef')();
  const serverRelativeUrl: string = (fileProps && fileProps.FileRef) ? fileProps.FileRef : (targetFolderSrvRel + '/' + file.name).replace(/\/+/g, '/');
  const absoluteUrl: string = webAbs + serverRelativeUrl;

  return { serverRelativeUrl, absoluteUrl };
}

private async resolveTargetFolderServerRelative(baseLibSrvRel: string, lessonId: number): Promise<string> {
  // If you donâ€™t want nesting: just ensure the doc lib exists and return it.
  if (!NEST_BY_COURSE_AND_MODULE) {
    await this.ensureFolderPathServerRelative(baseLibSrvRel);
    return baseLibSrvRel;
  }

  // Build nested path CourseAssets/Courses/<courseId>/Modules/<moduleId>
  const lesson = this.state.lessons.find((l) => l.Id === lessonId);
  if (!lesson) {
    await this.ensureFolderPathServerRelative(baseLibSrvRel);
    return baseLibSrvRel;
  }

  const mod = this.state.modules.find((m) => m.Id === lesson.ModuleId);
  const courseId = mod && typeof mod.CourseId === 'number' ? mod.CourseId : null;

  const parts: string[] = [baseLibSrvRel, 'Courses'];
  if (courseId) parts.push(String(courseId));
  if (mod) parts.push('Modules', String(mod.Id));

  const full = parts.join('/').replace(/\/+/g, '/');
  await this.ensureFolderPathServerRelative(full);
  return full;
}

private async ensureFolderPathServerRelative(serverRelativePath: string): Promise<void> {
  const sp = getSP(this.props.context);
  // Split into segments starting from the library root
  const path = serverRelativePath.replace(/^\/+/, '');
  const segments = path.split('/');
  if (segments.length === 0) return;

  // First segment might be 'sites', handle that by rebuilding as we go
  let current = '/' + segments[0];
  for (let i = 1; i < segments.length; i++) {
    current = (current + '/' + segments[i]).replace(/\/+/g, '/');
    try {
      // exists?
      await sp.web.getFolderByServerRelativePath(current).select('ServerRelativeUrl')();
    } catch (_) {
      // create
      await sp.web.folders.addUsingPath(current);
    }
  }
}