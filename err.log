import * as React from "react";
import { apiGet, apiPost } from "./common/ApiClient";
import CustomerLookup from "./customer/CustomerLookup";
import { ICustomerCard, ICustomerInfo, ICustomerLookupResult } from "./customer/ICustomerInfo";
import { IDisputeTransaction, IExistingDisputeRow } from "./models/IDisputeTransaction";
import { DISPUTE_REASONS, isAttachmentRequired } from "./common/DisputeReasons";
import { SharePointDisputeService } from "./common/SharePointDisputeService";

export type UiStatus = "idle" | "customerFound" | "starting" | "waiting" | "approved" | "rejected" | "failed" | "timeout";

export interface IProps {
  apiBaseUrl: string;
  spHttpClient: any; // SPHttpClient
  siteUrl: string;
  listTitle: string;
}

export interface IState {
  status: UiStatus;
  customer?: ICustomerInfo;

  message?: string;

  // PACI
  requestId?: string;
  secondsLeft: number;
  resultCode?: number;
  resultDescription?: string;

  cards?: ICustomerCard[];

  // Transactions (multiple)
  transactions: IDisputeTransaction[];

  // Existing
  loadingExisting: boolean;
  existingRows: IExistingDisputeRow[];

  submitting: boolean;
}

export default class FlowardClaim extends React.Component<IProps, IState> {
  private pollTimer?: number;
  private countdownTimer?: number;

  private spSvc: SharePointDisputeService;

  constructor(props: IProps) {
    super(props);

    this.spSvc = new SharePointDisputeService(props.spHttpClient, props.siteUrl, props.listTitle);

    this.state = {
      status: "idle",
      secondsLeft: 300,
      transactions: [],
      loadingExisting: false,
      existingRows: [],
      submitting: false
    };
  }

  public componentWillUnmount(): void {
    this.clearTimers();
  }

  public render(): React.ReactElement<IProps> {
    const { customer, cards, status, message, secondsLeft, requestId, transactions, existingRows, loadingExisting, submitting } = this.state;

    return (
      <div style={{ padding: 12, maxWidth: 1000 }}>
        <CustomerLookup
          apiBaseUrl={this.props.apiBaseUrl}
          onCustomerFound={this.onCustomerFound}
          onCustomerNotFound={this.onCustomerNotFound}
        />

        {customer && (
          <div style={{ marginTop: 12, border: "1px solid #ddd", padding: 12, borderRadius: 4 }}>
            <div style={{ marginBottom: 8 }}>
              <b>Customer:</b> {customer.fullNameEn} / {customer.fullNameAr}
            </div>

            <button
              onClick={this.startPaciAuth}
              disabled={status === "starting" || status === "waiting"}
              style={{ padding: "8px 14px" }}
            >
              Authenticate with PACI
            </button>

            {status === "waiting" && (
              <div style={{ marginTop: 10 }}>
                <div><b>RequestId:</b> {requestId}</div>
                <div><b>Time left:</b> {secondsLeft}s</div>
              </div>
            )}

            {message && <div style={{ marginTop: 10 }}>{message}</div>}

            {/* Existing transactions */}
            <div style={{ marginTop: 14 }}>
              <h4 style={{ margin: "10px 0" }}>Previous Transactions</h4>
              {loadingExisting ? (
                <div>Loading previous transactions...</div>
              ) : (
                this.renderExistingTable(existingRows)
              )}
            </div>

            {/* After PACI approval - allow adding multiple transactions */}
            {status === "approved" && cards && cards.length > 0 && (
              <div style={{ marginTop: 14, borderTop: "1px solid #eee", paddingTop: 12 }}>
                <h4 style={{ marginTop: 0 }}>Add Transactions</h4>

                <button onClick={this.addTransactionRow} style={{ padding: "6px 12px" }}>
                  + Add Transaction
                </button>

                {transactions.length === 0 && <div style={{ marginTop: 10 }}>No transactions added yet.</div>}

                {transactions.map((t) => this.renderTransactionRow(t, cards))}

                <div style={{ marginTop: 12 }}>
                  <button
                    onClick={this.submitToSharePoint}
                    disabled={submitting || transactions.length === 0}
                    style={{ padding: "8px 14px" }}
                  >
                    {submitting ? "Submitting..." : "Submit"}
                  </button>
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    );
  }

  private renderExistingTable(rows: IExistingDisputeRow[]): React.ReactElement<any> {
    if (!rows || rows.length === 0) {
      return <div>No previous transactions found.</div>;
    }

    return (
      <table style={{ width: "100%", borderCollapse: "collapse", fontSize: 12 }}>
        <thead>
          <tr>
            <th style={th}>ID</th>
            <th style={th}>Status</th>
            <th style={th}>Card</th>
            <th style={th}>Date</th>
            <th style={th}>Time</th>
            <th style={th}>Amount</th>
            <th style={th}>Merchant</th>
            <th style={th}>Reason</th>
            <th style={th}>Created</th>
          </tr>
        </thead>
        <tbody>
          {rows.map((r) => (
            <tr key={r.id}>
              <td style={td}>{r.id}</td>
              <td style={td}>{r.status || ""}</td>
              <td style={td}>{r.cardMasked || ""}</td>
              <td style={td}>{r.txnDate || ""}</td>
              <td style={td}>{r.txnTime || ""}</td>
              <td style={td}>{r.txnAmount !== undefined ? r.txnAmount : ""}</td>
              <td style={td}>{r.merchantName || ""}</td>
              <td style={td}>{r.disputeReason || ""}</td>
              <td style={td}>{r.created || ""}</td>
            </tr>
          ))}
        </tbody>
      </table>
    );
  }

  private renderTransactionRow(t: IDisputeTransaction, cards: ICustomerCard[]): React.ReactElement<any> {
    const attachmentNeeded = isAttachmentRequired(t.disputeReason);
    const rowError = this.validateOneTransaction(t);

    return (
      <div key={t.localId} style={{ marginTop: 12, border: "1px solid #ddd", padding: 12, borderRadius: 4 }}>
        <div style={{ display: "flex", justifyContent: "space-between", gap: 8 }}>
          <b>Transaction</b>
          <button onClick={() => this.removeTransactionRow(t.localId)} style={{ padding: "4px 10px" }}>
            Remove
          </button>
        </div>

        {rowError && <div style={{ marginTop: 6, color: "#b00020" }}>{rowError}</div>}

        <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 10, marginTop: 10 }}>
          <div>
            <div><b>Card</b></div>
            <select
              value={t.cardNo || ""}
              onChange={(e) => this.updateTransaction(t.localId, { cardNo: (e.target as HTMLSelectElement).value })}
              style={{ padding: 8, width: "100%" }}
            >
              <option value="">-- Select card --</option>
              {cards.map((c) => (
                <option key={c.cardNo} value={c.cardNo}>
                  {c.maskedCardNo}
                </option>
              ))}
            </select>
          </div>

          <div>
            <div><b>Dispute Reason</b></div>
            <select
              value={t.disputeReason || ""}
              onChange={(e) => this.updateTransaction(t.localId, { disputeReason: (e.target as HTMLSelectElement).value })}
              style={{ padding: 8, width: "100%" }}
            >
              {DISPUTE_REASONS.map((r) => (
                <option key={r.key} value={r.key}>
                  {r.text}
                </option>
              ))}
            </select>
            {attachmentNeeded && <div style={{ fontSize: 12, marginTop: 4 }}><b>Attachment is required</b> for this reason.</div>}
          </div>

          <div>
            <div><b>Transaction Date</b></div>
            <input
              type="date"
              value={t.txnDate || ""}
              onChange={(e) => this.updateTransaction(t.localId, { txnDate: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div>
            <div><b>Transaction Time</b></div>
            <input
              type="time"
              value={t.txnTime || ""}
              onChange={(e) => this.updateTransaction(t.localId, { txnTime: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div>
            <div><b>Transaction Amount</b></div>
            <input
              type="text"
              value={t.txnAmount || ""}
              onChange={(e) => {
                const v = (e.target as HTMLInputElement).value;
                if (/^\d*\.?\d*$/.test(v)) {
                  this.updateTransaction(t.localId, { txnAmount: v });
                }
              }}
              placeholder="e.g. 12.500"
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div>
            <div><b>Merchant Name</b></div>
            <input
              type="text"
              value={t.merchantName || ""}
              onChange={(e) => this.updateTransaction(t.localId, { merchantName: (e.target as HTMLInputElement).value })}
              style={{ padding: 8, width: "100%" }}
            />
          </div>

          <div style={{ gridColumn: "1 / span 2" }}>
            <div><b>Comment</b></div>
            <textarea
              value={t.comment || ""}
              onChange={(e) => this.updateTransaction(t.localId, { comment: (e.target as HTMLTextAreaElement).value })}
              style={{ padding: 8, width: "100%", minHeight: 70 }}
            />
          </div>

          <div style={{ gridColumn: "1 / span 2" }}>
            <div><b>Attachment {attachmentNeeded ? "(Required)" : "(Optional)"}</b></div>
            <input
              type="file"
              onChange={(e) => {
                const files = (e.target as HTMLInputElement).files;
                this.updateTransaction(t.localId, { attachment: files && files.length > 0 ? files[0] : null });
              }}
            />
            {t.attachment && <div style={{ fontSize: 12, marginTop: 4 }}>{t.attachment.name}</div>}
          </div>
        </div>
      </div>
    );
  }

  // ---------- CUSTOMER FLOW ----------

  private onCustomerFound = async (result: ICustomerLookupResult): Promise<void> => {
    this.clearTimers();

    this.setState({
      customer: result.customer,
      cards: result.cards,
      status: "customerFound",
      message: undefined,
      requestId: undefined,
      secondsLeft: 300,
      resultCode: undefined,
      resultDescription: undefined,
      transactions: [],
      loadingExisting: true,
      existingRows: []
    });

    // load existing disputes for civilId
    try {
      const rows = await this.spSvc.getExistingByCivilId(result.customer.civilId);
      this.setState({ existingRows: rows, loadingExisting: false });
    } catch (e: any) {
      this.setState({ existingRows: [], loadingExisting: false, message: "Failed to load previous transactions: " + (e?.message || "") });
    }
  };

  private onCustomerNotFound = (msg: string): void => {
    this.clearTimers();
    this.setState({
      customer: undefined,
      cards: undefined,
      status: "idle",
      message: msg,
      requestId: undefined,
      secondsLeft: 300,
      resultCode: undefined,
      resultDescription: undefined,
      transactions: [],
      existingRows: [],
      loadingExisting: false
    });
  };

  // ---------- PACI FLOW ----------

  private startPaciAuth = async (): Promise<void> => {
    const customer = this.state.customer;
    if (!customer || !customer.civilId) {
      this.setState({ status: "failed", message: "Please lookup valid Civil ID first." });
      return;
    }

    this.clearTimers();
    this.setState({ status: "starting", message: "Sending PACI authentication request...", secondsLeft: 300 });

    try {
      const url = this.props.apiBaseUrl.replace(/\/$/, "") + "/api/paci/initiate-auth";
      const resp = await apiPost<{ requestId: string }>(url, {
        authenticationReasonAr: "الحصول على تفويض العميل",
        authenticationReasonEn: "Get Customer Approval",
        civilNo: customer.civilId,
        assuranceLevel: "Medium",
        serviceDescriptionEN: "Refund claim for a Gift Card",
        serviceDescriptionAR: "طلب استرداد مبلغ لبطاقة الهدايا",
        additionalData: "",
        challenge: ""
      });

      if (!resp || !resp.requestId) {
        this.setState({ status: "failed", message: "No RequestId returned from PACI initiate API." });
        return;
      }

      this.setState({ status: "waiting", requestId: resp.requestId, message: "Waiting for customer approval..." });
      this.startCountdown();
      this.startPolling(resp.requestId);
    } catch (e: any) {
      this.setState({ status: "failed", message: e?.message || "Failed to initiate PACI auth." });
    }
  };

  private startCountdown(): void {
    this.countdownTimer = window.setInterval(() => {
      this.setState((prev) => {
        const next = prev.secondsLeft - 1;
        if (next <= 0) {
          this.clearTimers();
          return { ...prev, secondsLeft: 0, status: "timeout", message: "Timed out (5 minutes). No response received." };
        }
        return { ...prev, secondsLeft: next };
      });
    }, 1000);
  }

  private startPolling(requestId: string): void {
    this.pollTimer = window.setInterval(async () => {
      try {
        const url = this.props.apiBaseUrl.replace(/\/$/, "") + "/api/paci/status/" + encodeURIComponent(requestId);

        const s = await apiGet<{
          isProcessed: boolean;
          resultCode?: number;
          resultDescription?: string;
        }>(url);

        if (!s || !s.isProcessed) return;

        this.clearTimers();

        const rc = s.resultCode;
        const desc = s.resultDescription;

        if (rc === 10) {
          this.setState({ status: "approved", resultCode: rc, resultDescription: desc, message: "PACI Approved" });
        } else if (rc === 40) {
          this.setState({ status: "rejected", resultCode: rc, resultDescription: desc, message: desc || "Rejected" });
        } else {
          this.setState({ status: "failed", resultCode: rc, resultDescription: desc, message: desc || "Failed" });
        }
      } catch {
        // keep polling silently
      }
    }, 3000);
  }

  // ---------- TRANSACTION ROWS ----------

  private addTransactionRow = (): void => {
    const id = "t_" + new Date().getTime() + "_" + Math.floor(Math.random() * 1000);

    const next: IDisputeTransaction = { localId: id, attachment: null };
    this.setState((prev) => ({
      transactions: prev.transactions.concat([next])
    }));
  };

  private removeTransactionRow = (localId: string): void => {
    this.setState((prev) => ({
      transactions: prev.transactions.filter((x) => x.localId !== localId)
    }));
  };

  private updateTransaction = (localId: string, patch: Partial<IDisputeTransaction>): void => {
    this.setState((prev) => ({
      transactions: prev.transactions.map((x) => (x.localId === localId ? { ...x, ...patch } : x))
    }));
  };

  // ---------- VALIDATION ----------

  private validateOneTransaction(t: IDisputeTransaction): string | null {
    if (!t.cardNo) return "Card is required.";
    if (!t.txnDate) return "Transaction date is required.";
    if (!t.txnTime) return "Transaction time is required.";
    if (!t.txnAmount || isNaN(Number(t.txnAmount))) return "Valid amount is required.";
    if (!t.merchantName) return "Merchant name is required.";
    if (!t.disputeReason) return "Dispute reason is required.";

    if (isAttachmentRequired(t.disputeReason) && !t.attachment) {
      return "Attachment is required for selected dispute reason.";
    }

    return null;
  }

  private validateAll(): string | null {
    if (this.state.status !== "approved") return "PACI must be approved before submitting.";
    if (!this.state.customer) return "Customer is missing.";
    if (!this.state.requestId) return "PACI RequestId is missing.";
    if (!this.state.transactions || this.state.transactions.length === 0) return "Please add at least one transaction.";

    for (let i = 0; i < this.state.transactions.length; i++) {
      const err = this.validateOneTransaction(this.state.transactions[i]);
      if (err) return "Row " + (i + 1) + ": " + err;
    }

    return null;
  }

  // ---------- SUBMIT TO SHAREPOINT ----------

  private submitToSharePoint = async (): Promise<void> => {
    const err = this.validateAll();
    if (err) {
      this.setState({ message: err });
      return;
    }

    const customer = this.state.customer!;
    const paciRequestId = this.state.requestId!;
    const cards = this.state.cards || [];

    this.setState({ submitting: true, message: "Submitting to SharePoint..." });

    try {
      for (let i = 0; i < this.state.transactions.length; i++) {
        const t = this.state.transactions[i];

        // get masked card
        let masked = "";
        for (let c = 0; c < cards.length; c++) {
          if (cards[c].cardNo === t.cardNo) {
            masked = cards[c].maskedCardNo;
            break;
          }
        }

        const itemId = await this.spSvc.addDisputeItem({
          civilId: customer.civilId,
          paciRequestId: paciRequestId,
          cardNo: t.cardNo!,
          maskedCardNo: masked,
          txnDate: t.txnDate!,
          txnTime: t.txnTime!,
          txnAmount: Number(t.txnAmount),
          merchantName: t.merchantName!,
          disputeReason: t.disputeReason!,
          comment: t.comment || ""
        });

        if (t.attachment) {
          await this.spSvc.addAttachment(itemId, t.attachment);
        }
      }

      // refresh existing table
      const rows = await this.spSvc.getExistingByCivilId(customer.civilId);

      this.setState({
        submitting: false,
        message: "Submitted successfully.",
        transactions: [],
        existingRows: rows
      });
    } catch (e: any) {
      this.setState({
        submitting: false,
        message: "Submit failed: " + (e?.message || e?.toString() || "")
      });
    }
  };

  // ---------- TIMERS ----------

  private clearTimers(): void {
    if (this.pollTimer !== undefined) {
      window.clearInterval(this.pollTimer);
      this.pollTimer = undefined;
    }
    if (this.countdownTimer !== undefined) {
      window.clearInterval(this.countdownTimer);
      this.countdownTimer = undefined;
    }
  }
}

const th: React.CSSProperties = { borderBottom: "1px solid #ddd", textAlign: "left", padding: 6 };
const td: React.CSSProperties = { borderBottom: "1px solid #f0f0f0", padding: 6, verticalAlign: "top" };
